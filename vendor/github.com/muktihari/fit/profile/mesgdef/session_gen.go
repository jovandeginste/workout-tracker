// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/internal/sliceutil"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"math"
	"time"
)

// Session is a Session message.
//
// Note: The order of the fields is optimized using a memory alignment algorithm.
// Do not rely on field indices, such as when using reflection.
type Session struct {
	Timestamp                     time.Time // Units: s; Sesson end time.
	StartTime                     time.Time
	TimeInHrZone                  []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInSpeedZone               []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInCadenceZone             []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInPowerZone               []uint32 // Array: [N]; Scale: 1000; Units: s
	OpponentName                  string
	StrokeCount                   []uint16 // Array: [N]; Units: counts; stroke_type enum used as the index
	ZoneCount                     []uint16 // Array: [N]; Units: counts; zone number used as the index
	AvgTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
	MinTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
	MaxTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
	AvgSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
	MinSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
	MaxSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
	SportProfileName              string   // Sport name from associated sport mesg
	AvgLeftPowerPhase             []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
	AvgLeftPowerPhasePeak         []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhase            []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhasePeak        []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
	AvgPowerPosition              []uint16 // Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
	MaxPowerPosition              []uint16 // Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
	AvgCadencePosition            []uint8  // Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
	MaxCadencePosition            []uint8  // Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
	StartPositionLat              int32    // Units: semicircles
	StartPositionLong             int32    // Units: semicircles
	TotalElapsedTime              uint32   // Scale: 1000; Units: s; Time (includes pauses)
	TotalTimerTime                uint32   // Scale: 1000; Units: s; Timer Time (excludes pauses)
	TotalDistance                 uint32   // Scale: 100; Units: m
	TotalCycles                   uint32   // Units: cycles
	NecLat                        int32    // Units: semicircles; North east corner latitude
	NecLong                       int32    // Units: semicircles; North east corner longitude
	SwcLat                        int32    // Units: semicircles; South west corner latitude
	SwcLong                       int32    // Units: semicircles; South west corner longitude
	EndPositionLat                int32    // Units: semicircles
	EndPositionLong               int32    // Units: semicircles
	AvgStrokeCount                uint32   // Scale: 10; Units: strokes/lap
	TotalWork                     uint32   // Units: J
	TotalMovingTime               uint32   // Scale: 1000; Units: s
	AvgLapTime                    uint32   // Scale: 1000; Units: s
	TimeStanding                  uint32   // Scale: 1000; Units: s; Total time spend in the standing position
	EnhancedAvgSpeed              uint32   // Scale: 1000; Units: m/s; total_distance / total_timer_time
	EnhancedMaxSpeed              uint32   // Scale: 1000; Units: m/s
	EnhancedAvgAltitude           uint32   // Scale: 5; Offset: 500; Units: m
	EnhancedMinAltitude           uint32   // Scale: 5; Offset: 500; Units: m
	EnhancedMaxAltitude           uint32   // Scale: 5; Offset: 500; Units: m
	AvgDepth                      uint32   // Scale: 1000; Units: m; 0 if above water
	MaxDepth                      uint32   // Scale: 1000; Units: m; 0 if above water
	SurfaceInterval               uint32   // Units: s; Time since end of last dive
	DiveNumber                    uint32
	TrainingLoadPeak              int32                // Scale: 65536
	TotalGrit                     float32              // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	TotalFlow                     float32              // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	AvgGrit                       float32              // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	AvgFlow                       float32              // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	MessageIndex                  typedef.MessageIndex // Selected bit is set for the current session.
	TotalCalories                 uint16               // Units: kcal
	TotalFatCalories              uint16               // Units: kcal
	AvgSpeed                      uint16               // Scale: 1000; Units: m/s; total_distance / total_timer_time
	MaxSpeed                      uint16               // Scale: 1000; Units: m/s
	AvgPower                      uint16               // Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                      uint16               // Units: watts
	TotalAscent                   uint16               // Units: m
	TotalDescent                  uint16               // Units: m
	FirstLapIndex                 uint16
	NumLaps                       uint16
	NumLengths                    uint16 // Units: lengths; # of lengths of swim pool
	NormalizedPower               uint16 // Units: watts
	TrainingStressScore           uint16 // Scale: 10; Units: tss
	IntensityFactor               uint16 // Scale: 1000; Units: if
	LeftRightBalance              typedef.LeftRightBalance100
	AvgStrokeDistance             uint16 // Scale: 100; Units: m
	PoolLength                    uint16 // Scale: 100; Units: m
	ThresholdPower                uint16 // Units: watts
	NumActiveLengths              uint16 // Units: lengths; # of active lengths of swim pool
	AvgAltitude                   uint16 // Scale: 5; Offset: 500; Units: m
	MaxAltitude                   uint16 // Scale: 5; Offset: 500; Units: m
	AvgGrade                      int16  // Scale: 100; Units: %
	AvgPosGrade                   int16  // Scale: 100; Units: %
	AvgNegGrade                   int16  // Scale: 100; Units: %
	MaxPosGrade                   int16  // Scale: 100; Units: %
	MaxNegGrade                   int16  // Scale: 100; Units: %
	AvgPosVerticalSpeed           int16  // Scale: 1000; Units: m/s
	AvgNegVerticalSpeed           int16  // Scale: 1000; Units: m/s
	MaxPosVerticalSpeed           int16  // Scale: 1000; Units: m/s
	MaxNegVerticalSpeed           int16  // Scale: 1000; Units: m/s
	BestLapIndex                  uint16
	MinAltitude                   uint16 // Scale: 5; Offset: 500; Units: m
	PlayerScore                   uint16
	OpponentScore                 uint16
	MaxBallSpeed                  uint16 // Scale: 100; Units: m/s
	AvgBallSpeed                  uint16 // Scale: 100; Units: m/s
	AvgVerticalOscillation        uint16 // Scale: 10; Units: mm
	AvgStanceTimePercent          uint16 // Scale: 100; Units: percent
	AvgStanceTime                 uint16 // Scale: 10; Units: ms
	StandCount                    uint16 // Number of transitions to the standing state
	AvgLevMotorPower              uint16 // Units: watts; lev average motor power during session
	MaxLevMotorPower              uint16 // Units: watts; lev maximum motor power during session
	AvgVerticalRatio              uint16 // Scale: 100; Units: percent
	AvgStanceTimeBalance          uint16 // Scale: 100; Units: percent
	AvgStepLength                 uint16 // Scale: 10; Units: mm
	AvgVam                        uint16 // Scale: 1000; Units: m/s
	StartN2                       uint16 // Units: percent
	EndN2                         uint16 // Units: percent
	O2Toxicity                    uint16 // Units: OTUs
	EnhancedAvgRespirationRate    uint16 // Scale: 100; Units: Breaths/min
	EnhancedMaxRespirationRate    uint16 // Scale: 100; Units: Breaths/min
	EnhancedMinRespirationRate    uint16 // Scale: 100
	JumpCount                     uint16
	AvgCoreTemperature            uint16            // Scale: 100; Units: C
	MinCoreTemperature            uint16            // Scale: 100; Units: C
	MaxCoreTemperature            uint16            // Scale: 100; Units: C
	Event                         typedef.Event     // session
	EventType                     typedef.EventType // stop
	Sport                         typedef.Sport
	SubSport                      typedef.SubSport
	AvgHeartRate                  uint8 // Units: bpm; average heart rate (excludes pause time)
	MaxHeartRate                  uint8 // Units: bpm
	AvgCadence                    uint8 // Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                    uint8 // Units: rpm
	TotalTrainingEffect           uint8 // Scale: 10
	EventGroup                    uint8
	Trigger                       typedef.SessionTrigger
	SwimStroke                    typedef.SwimStroke // Units: swim_stroke
	PoolLengthUnit                typedef.DisplayMeasure
	GpsAccuracy                   uint8 // Units: m
	AvgTemperature                int8  // Units: C
	MaxTemperature                int8  // Units: C
	MinHeartRate                  uint8 // Units: bpm
	AvgFractionalCadence          uint8 // Scale: 128; Units: rpm; fractional part of the avg_cadence
	MaxFractionalCadence          uint8 // Scale: 128; Units: rpm; fractional part of the max_cadence
	TotalFractionalCycles         uint8 // Scale: 128; Units: cycles; fractional part of the total_cycles
	AvgLeftTorqueEffectiveness    uint8 // Scale: 2; Units: percent
	AvgRightTorqueEffectiveness   uint8 // Scale: 2; Units: percent
	AvgLeftPedalSmoothness        uint8 // Scale: 2; Units: percent
	AvgRightPedalSmoothness       uint8 // Scale: 2; Units: percent
	AvgCombinedPedalSmoothness    uint8 // Scale: 2; Units: percent
	SportIndex                    uint8
	AvgLeftPco                    int8  // Units: mm; Average platform center offset Left
	AvgRightPco                   int8  // Units: mm; Average platform center offset Right
	LevBatteryConsumption         uint8 // Scale: 2; Units: percent; lev battery consumption during session
	TotalAnaerobicTrainingEffect  uint8 // Scale: 10
	StartCns                      uint8 // Units: percent
	EndCns                        uint8 // Units: percent
	AvgRespirationRate            uint8
	MaxRespirationRate            uint8
	MinRespirationRate            uint8
	MinTemperature                int8  // Units: C
	WorkoutFeel                   uint8 // A 0-100 scale representing how a user felt while performing a workout. Low values are considered feeling bad, while high values are good.
	WorkoutRpe                    uint8 // Common Borg CR10 / 0-10 RPE scale, multiplied 10x.. Aggregate score for all workouts in a single session.
	AvgSpo2                       uint8 // Units: percent; Average SPO2 for the monitoring session
	AvgStress                     uint8 // Units: percent; Average stress for the monitoring session
	SdrrHrv                       uint8 // Units: mS; Standard deviation of R-R interval (SDRR) - Heart rate variability measure most useful for wellness users.
	RmssdHrv                      uint8 // Units: mS; Root mean square successive difference (RMSSD) - Heart rate variability measure most useful for athletes
	TotalFractionalAscent         uint8 // Scale: 100; Units: m; fractional part of total_ascent
	TotalFractionalDescent        uint8 // Scale: 100; Units: m; fractional part of total_descent

	state [23]uint8 // Used for tracking expanded fields.

	UnknownFields   []proto.Field          // UnknownFields are fields that are exist but they are not defined in Profile.xlsx
	DeveloperFields []proto.DeveloperField // DeveloperFields are custom data fields [Added since protocol version 2.0]
}

// NewSession creates new Session struct based on given mesg.
// If mesg is nil, it will return Session with all fields being set to its corresponding invalid value.
func NewSession(mesg *proto.Message) *Session {
	vals := [255]proto.Value{}

	var state [23]uint8
	var unknownFields []proto.Field
	var developerFields []proto.DeveloperField
	if mesg != nil {
		arr := pool.Get().(*[poolsize]proto.Field)
		unknownFields = arr[:0]
		for i := range mesg.Fields {
			if mesg.Fields[i].Num > 254 || mesg.Fields[i].Name == factory.NameUnknown {
				unknownFields = append(unknownFields, mesg.Fields[i])
				continue
			}
			if mesg.Fields[i].Num < 181 && mesg.Fields[i].IsExpandedField {
				pos := mesg.Fields[i].Num / 8
				state[pos] |= 1 << (mesg.Fields[i].Num - (8 * pos))
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		unknownFields = sliceutil.Clone(unknownFields)
		*arr = [poolsize]proto.Field{}
		pool.Put(arr)
		developerFields = mesg.DeveloperFields
	}

	return &Session{
		MessageIndex:                  typedef.MessageIndex(vals[254].Uint16()),
		Timestamp:                     datetime.ToTime(vals[253].Uint32()),
		Event:                         typedef.Event(vals[0].Uint8()),
		EventType:                     typedef.EventType(vals[1].Uint8()),
		StartTime:                     datetime.ToTime(vals[2].Uint32()),
		StartPositionLat:              vals[3].Int32(),
		StartPositionLong:             vals[4].Int32(),
		Sport:                         typedef.Sport(vals[5].Uint8()),
		SubSport:                      typedef.SubSport(vals[6].Uint8()),
		TotalElapsedTime:              vals[7].Uint32(),
		TotalTimerTime:                vals[8].Uint32(),
		TotalDistance:                 vals[9].Uint32(),
		TotalCycles:                   vals[10].Uint32(),
		TotalCalories:                 vals[11].Uint16(),
		TotalFatCalories:              vals[13].Uint16(),
		AvgSpeed:                      vals[14].Uint16(),
		MaxSpeed:                      vals[15].Uint16(),
		AvgHeartRate:                  vals[16].Uint8(),
		MaxHeartRate:                  vals[17].Uint8(),
		AvgCadence:                    vals[18].Uint8(),
		MaxCadence:                    vals[19].Uint8(),
		AvgPower:                      vals[20].Uint16(),
		MaxPower:                      vals[21].Uint16(),
		TotalAscent:                   vals[22].Uint16(),
		TotalDescent:                  vals[23].Uint16(),
		TotalTrainingEffect:           vals[24].Uint8(),
		FirstLapIndex:                 vals[25].Uint16(),
		NumLaps:                       vals[26].Uint16(),
		EventGroup:                    vals[27].Uint8(),
		Trigger:                       typedef.SessionTrigger(vals[28].Uint8()),
		NecLat:                        vals[29].Int32(),
		NecLong:                       vals[30].Int32(),
		SwcLat:                        vals[31].Int32(),
		SwcLong:                       vals[32].Int32(),
		NumLengths:                    vals[33].Uint16(),
		NormalizedPower:               vals[34].Uint16(),
		TrainingStressScore:           vals[35].Uint16(),
		IntensityFactor:               vals[36].Uint16(),
		LeftRightBalance:              typedef.LeftRightBalance100(vals[37].Uint16()),
		EndPositionLat:                vals[38].Int32(),
		EndPositionLong:               vals[39].Int32(),
		AvgStrokeCount:                vals[41].Uint32(),
		AvgStrokeDistance:             vals[42].Uint16(),
		SwimStroke:                    typedef.SwimStroke(vals[43].Uint8()),
		PoolLength:                    vals[44].Uint16(),
		ThresholdPower:                vals[45].Uint16(),
		PoolLengthUnit:                typedef.DisplayMeasure(vals[46].Uint8()),
		NumActiveLengths:              vals[47].Uint16(),
		TotalWork:                     vals[48].Uint32(),
		AvgAltitude:                   vals[49].Uint16(),
		MaxAltitude:                   vals[50].Uint16(),
		GpsAccuracy:                   vals[51].Uint8(),
		AvgGrade:                      vals[52].Int16(),
		AvgPosGrade:                   vals[53].Int16(),
		AvgNegGrade:                   vals[54].Int16(),
		MaxPosGrade:                   vals[55].Int16(),
		MaxNegGrade:                   vals[56].Int16(),
		AvgTemperature:                vals[57].Int8(),
		MaxTemperature:                vals[58].Int8(),
		TotalMovingTime:               vals[59].Uint32(),
		AvgPosVerticalSpeed:           vals[60].Int16(),
		AvgNegVerticalSpeed:           vals[61].Int16(),
		MaxPosVerticalSpeed:           vals[62].Int16(),
		MaxNegVerticalSpeed:           vals[63].Int16(),
		MinHeartRate:                  vals[64].Uint8(),
		TimeInHrZone:                  vals[65].SliceUint32(),
		TimeInSpeedZone:               vals[66].SliceUint32(),
		TimeInCadenceZone:             vals[67].SliceUint32(),
		TimeInPowerZone:               vals[68].SliceUint32(),
		AvgLapTime:                    vals[69].Uint32(),
		BestLapIndex:                  vals[70].Uint16(),
		MinAltitude:                   vals[71].Uint16(),
		PlayerScore:                   vals[82].Uint16(),
		OpponentScore:                 vals[83].Uint16(),
		OpponentName:                  vals[84].String(),
		StrokeCount:                   vals[85].SliceUint16(),
		ZoneCount:                     vals[86].SliceUint16(),
		MaxBallSpeed:                  vals[87].Uint16(),
		AvgBallSpeed:                  vals[88].Uint16(),
		AvgVerticalOscillation:        vals[89].Uint16(),
		AvgStanceTimePercent:          vals[90].Uint16(),
		AvgStanceTime:                 vals[91].Uint16(),
		AvgFractionalCadence:          vals[92].Uint8(),
		MaxFractionalCadence:          vals[93].Uint8(),
		TotalFractionalCycles:         vals[94].Uint8(),
		AvgTotalHemoglobinConc:        vals[95].SliceUint16(),
		MinTotalHemoglobinConc:        vals[96].SliceUint16(),
		MaxTotalHemoglobinConc:        vals[97].SliceUint16(),
		AvgSaturatedHemoglobinPercent: vals[98].SliceUint16(),
		MinSaturatedHemoglobinPercent: vals[99].SliceUint16(),
		MaxSaturatedHemoglobinPercent: vals[100].SliceUint16(),
		AvgLeftTorqueEffectiveness:    vals[101].Uint8(),
		AvgRightTorqueEffectiveness:   vals[102].Uint8(),
		AvgLeftPedalSmoothness:        vals[103].Uint8(),
		AvgRightPedalSmoothness:       vals[104].Uint8(),
		AvgCombinedPedalSmoothness:    vals[105].Uint8(),
		SportProfileName:              vals[110].String(),
		SportIndex:                    vals[111].Uint8(),
		TimeStanding:                  vals[112].Uint32(),
		StandCount:                    vals[113].Uint16(),
		AvgLeftPco:                    vals[114].Int8(),
		AvgRightPco:                   vals[115].Int8(),
		AvgLeftPowerPhase:             vals[116].SliceUint8(),
		AvgLeftPowerPhasePeak:         vals[117].SliceUint8(),
		AvgRightPowerPhase:            vals[118].SliceUint8(),
		AvgRightPowerPhasePeak:        vals[119].SliceUint8(),
		AvgPowerPosition:              vals[120].SliceUint16(),
		MaxPowerPosition:              vals[121].SliceUint16(),
		AvgCadencePosition:            vals[122].SliceUint8(),
		MaxCadencePosition:            vals[123].SliceUint8(),
		EnhancedAvgSpeed:              vals[124].Uint32(),
		EnhancedMaxSpeed:              vals[125].Uint32(),
		EnhancedAvgAltitude:           vals[126].Uint32(),
		EnhancedMinAltitude:           vals[127].Uint32(),
		EnhancedMaxAltitude:           vals[128].Uint32(),
		AvgLevMotorPower:              vals[129].Uint16(),
		MaxLevMotorPower:              vals[130].Uint16(),
		LevBatteryConsumption:         vals[131].Uint8(),
		AvgVerticalRatio:              vals[132].Uint16(),
		AvgStanceTimeBalance:          vals[133].Uint16(),
		AvgStepLength:                 vals[134].Uint16(),
		TotalAnaerobicTrainingEffect:  vals[137].Uint8(),
		AvgVam:                        vals[139].Uint16(),
		AvgDepth:                      vals[140].Uint32(),
		MaxDepth:                      vals[141].Uint32(),
		SurfaceInterval:               vals[142].Uint32(),
		StartCns:                      vals[143].Uint8(),
		EndCns:                        vals[144].Uint8(),
		StartN2:                       vals[145].Uint16(),
		EndN2:                         vals[146].Uint16(),
		AvgRespirationRate:            vals[147].Uint8(),
		MaxRespirationRate:            vals[148].Uint8(),
		MinRespirationRate:            vals[149].Uint8(),
		MinTemperature:                vals[150].Int8(),
		O2Toxicity:                    vals[155].Uint16(),
		DiveNumber:                    vals[156].Uint32(),
		TrainingLoadPeak:              vals[168].Int32(),
		EnhancedAvgRespirationRate:    vals[169].Uint16(),
		EnhancedMaxRespirationRate:    vals[170].Uint16(),
		EnhancedMinRespirationRate:    vals[180].Uint16(),
		TotalGrit:                     vals[181].Float32(),
		TotalFlow:                     vals[182].Float32(),
		JumpCount:                     vals[183].Uint16(),
		AvgGrit:                       vals[186].Float32(),
		AvgFlow:                       vals[187].Float32(),
		WorkoutFeel:                   vals[192].Uint8(),
		WorkoutRpe:                    vals[193].Uint8(),
		AvgSpo2:                       vals[194].Uint8(),
		AvgStress:                     vals[195].Uint8(),
		SdrrHrv:                       vals[197].Uint8(),
		RmssdHrv:                      vals[198].Uint8(),
		TotalFractionalAscent:         vals[199].Uint8(),
		TotalFractionalDescent:        vals[200].Uint8(),
		AvgCoreTemperature:            vals[208].Uint16(),
		MinCoreTemperature:            vals[209].Uint16(),
		MaxCoreTemperature:            vals[210].Uint16(),

		state: state,

		UnknownFields:   unknownFields,
		DeveloperFields: developerFields,
	}
}

// ToMesg converts Session into proto.Message. If options is nil, default options will be used.
func (m *Session) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
		options.Factory = factory.StandardFactory()
	}

	fac := options.Factory

	arr := pool.Get().(*[poolsize]proto.Field)
	fields := arr[:0]

	mesg := proto.Message{Num: typedef.MesgNumSession}

	if m.MessageIndex != typedef.MessageIndexInvalid {
		field := fac.CreateField(mesg.Num, 254)
		field.Value = proto.Uint16(uint16(m.MessageIndex))
		fields = append(fields, field)
	}
	if !m.Timestamp.Before(datetime.Epoch()) {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = proto.Uint32(uint32(m.Timestamp.Sub(datetime.Epoch()).Seconds()))
		fields = append(fields, field)
	}
	if m.Event != typedef.EventInvalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = proto.Uint8(byte(m.Event))
		fields = append(fields, field)
	}
	if m.EventType != typedef.EventTypeInvalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = proto.Uint8(byte(m.EventType))
		fields = append(fields, field)
	}
	if !m.StartTime.Before(datetime.Epoch()) {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = proto.Uint32(uint32(m.StartTime.Sub(datetime.Epoch()).Seconds()))
		fields = append(fields, field)
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = proto.Int32(m.StartPositionLat)
		fields = append(fields, field)
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = proto.Int32(m.StartPositionLong)
		fields = append(fields, field)
	}
	if m.Sport != typedef.SportInvalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = proto.Uint8(byte(m.Sport))
		fields = append(fields, field)
	}
	if m.SubSport != typedef.SubSportInvalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = proto.Uint8(byte(m.SubSport))
		fields = append(fields, field)
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = proto.Uint32(m.TotalElapsedTime)
		fields = append(fields, field)
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = proto.Uint32(m.TotalTimerTime)
		fields = append(fields, field)
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = proto.Uint32(m.TotalDistance)
		fields = append(fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = proto.Uint32(m.TotalCycles)
		fields = append(fields, field)
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = proto.Uint16(m.TotalCalories)
		fields = append(fields, field)
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = proto.Uint16(m.TotalFatCalories)
		fields = append(fields, field)
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 14)
		field.Value = proto.Uint16(m.AvgSpeed)
		fields = append(fields, field)
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 15)
		field.Value = proto.Uint16(m.MaxSpeed)
		fields = append(fields, field)
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 16)
		field.Value = proto.Uint8(m.AvgHeartRate)
		fields = append(fields, field)
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = proto.Uint8(m.MaxHeartRate)
		fields = append(fields, field)
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = proto.Uint8(m.AvgCadence)
		fields = append(fields, field)
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = proto.Uint8(m.MaxCadence)
		fields = append(fields, field)
	}
	if m.AvgPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 20)
		field.Value = proto.Uint16(m.AvgPower)
		fields = append(fields, field)
	}
	if m.MaxPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 21)
		field.Value = proto.Uint16(m.MaxPower)
		fields = append(fields, field)
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 22)
		field.Value = proto.Uint16(m.TotalAscent)
		fields = append(fields, field)
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 23)
		field.Value = proto.Uint16(m.TotalDescent)
		fields = append(fields, field)
	}
	if m.TotalTrainingEffect != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 24)
		field.Value = proto.Uint8(m.TotalTrainingEffect)
		fields = append(fields, field)
	}
	if m.FirstLapIndex != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 25)
		field.Value = proto.Uint16(m.FirstLapIndex)
		fields = append(fields, field)
	}
	if m.NumLaps != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 26)
		field.Value = proto.Uint16(m.NumLaps)
		fields = append(fields, field)
	}
	if m.EventGroup != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 27)
		field.Value = proto.Uint8(m.EventGroup)
		fields = append(fields, field)
	}
	if m.Trigger != typedef.SessionTriggerInvalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = proto.Uint8(byte(m.Trigger))
		fields = append(fields, field)
	}
	if m.NecLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = proto.Int32(m.NecLat)
		fields = append(fields, field)
	}
	if m.NecLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = proto.Int32(m.NecLong)
		fields = append(fields, field)
	}
	if m.SwcLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = proto.Int32(m.SwcLat)
		fields = append(fields, field)
	}
	if m.SwcLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = proto.Int32(m.SwcLong)
		fields = append(fields, field)
	}
	if m.NumLengths != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = proto.Uint16(m.NumLengths)
		fields = append(fields, field)
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 34)
		field.Value = proto.Uint16(m.NormalizedPower)
		fields = append(fields, field)
	}
	if m.TrainingStressScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 35)
		field.Value = proto.Uint16(m.TrainingStressScore)
		fields = append(fields, field)
	}
	if m.IntensityFactor != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 36)
		field.Value = proto.Uint16(m.IntensityFactor)
		fields = append(fields, field)
	}
	if m.LeftRightBalance != typedef.LeftRightBalance100Invalid {
		field := fac.CreateField(mesg.Num, 37)
		field.Value = proto.Uint16(uint16(m.LeftRightBalance))
		fields = append(fields, field)
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 38)
		field.Value = proto.Int32(m.EndPositionLat)
		fields = append(fields, field)
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = proto.Int32(m.EndPositionLong)
		fields = append(fields, field)
	}
	if m.AvgStrokeCount != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = proto.Uint32(m.AvgStrokeCount)
		fields = append(fields, field)
	}
	if m.AvgStrokeDistance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = proto.Uint16(m.AvgStrokeDistance)
		fields = append(fields, field)
	}
	if m.SwimStroke != typedef.SwimStrokeInvalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = proto.Uint8(byte(m.SwimStroke))
		fields = append(fields, field)
	}
	if m.PoolLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = proto.Uint16(m.PoolLength)
		fields = append(fields, field)
	}
	if m.ThresholdPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = proto.Uint16(m.ThresholdPower)
		fields = append(fields, field)
	}
	if m.PoolLengthUnit != typedef.DisplayMeasureInvalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = proto.Uint8(byte(m.PoolLengthUnit))
		fields = append(fields, field)
	}
	if m.NumActiveLengths != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = proto.Uint16(m.NumActiveLengths)
		fields = append(fields, field)
	}
	if m.TotalWork != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = proto.Uint32(m.TotalWork)
		fields = append(fields, field)
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = proto.Uint16(m.AvgAltitude)
		fields = append(fields, field)
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = proto.Uint16(m.MaxAltitude)
		fields = append(fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = proto.Uint8(m.GpsAccuracy)
		fields = append(fields, field)
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = proto.Int16(m.AvgGrade)
		fields = append(fields, field)
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = proto.Int16(m.AvgPosGrade)
		fields = append(fields, field)
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = proto.Int16(m.AvgNegGrade)
		fields = append(fields, field)
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = proto.Int16(m.MaxPosGrade)
		fields = append(fields, field)
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = proto.Int16(m.MaxNegGrade)
		fields = append(fields, field)
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = proto.Int8(m.AvgTemperature)
		fields = append(fields, field)
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = proto.Int8(m.MaxTemperature)
		fields = append(fields, field)
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = proto.Uint32(m.TotalMovingTime)
		fields = append(fields, field)
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 60)
		field.Value = proto.Int16(m.AvgPosVerticalSpeed)
		fields = append(fields, field)
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 61)
		field.Value = proto.Int16(m.AvgNegVerticalSpeed)
		fields = append(fields, field)
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = proto.Int16(m.MaxPosVerticalSpeed)
		fields = append(fields, field)
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 63)
		field.Value = proto.Int16(m.MaxNegVerticalSpeed)
		fields = append(fields, field)
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 64)
		field.Value = proto.Uint8(m.MinHeartRate)
		fields = append(fields, field)
	}
	if m.TimeInHrZone != nil {
		field := fac.CreateField(mesg.Num, 65)
		field.Value = proto.SliceUint32(m.TimeInHrZone)
		fields = append(fields, field)
	}
	if m.TimeInSpeedZone != nil {
		field := fac.CreateField(mesg.Num, 66)
		field.Value = proto.SliceUint32(m.TimeInSpeedZone)
		fields = append(fields, field)
	}
	if m.TimeInCadenceZone != nil {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = proto.SliceUint32(m.TimeInCadenceZone)
		fields = append(fields, field)
	}
	if m.TimeInPowerZone != nil {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = proto.SliceUint32(m.TimeInPowerZone)
		fields = append(fields, field)
	}
	if m.AvgLapTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = proto.Uint32(m.AvgLapTime)
		fields = append(fields, field)
	}
	if m.BestLapIndex != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = proto.Uint16(m.BestLapIndex)
		fields = append(fields, field)
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = proto.Uint16(m.MinAltitude)
		fields = append(fields, field)
	}
	if m.PlayerScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = proto.Uint16(m.PlayerScore)
		fields = append(fields, field)
	}
	if m.OpponentScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = proto.Uint16(m.OpponentScore)
		fields = append(fields, field)
	}
	if m.OpponentName != basetype.StringInvalid {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = proto.String(m.OpponentName)
		fields = append(fields, field)
	}
	if m.StrokeCount != nil {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = proto.SliceUint16(m.StrokeCount)
		fields = append(fields, field)
	}
	if m.ZoneCount != nil {
		field := fac.CreateField(mesg.Num, 86)
		field.Value = proto.SliceUint16(m.ZoneCount)
		fields = append(fields, field)
	}
	if m.MaxBallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = proto.Uint16(m.MaxBallSpeed)
		fields = append(fields, field)
	}
	if m.AvgBallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 88)
		field.Value = proto.Uint16(m.AvgBallSpeed)
		fields = append(fields, field)
	}
	if m.AvgVerticalOscillation != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 89)
		field.Value = proto.Uint16(m.AvgVerticalOscillation)
		fields = append(fields, field)
	}
	if m.AvgStanceTimePercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 90)
		field.Value = proto.Uint16(m.AvgStanceTimePercent)
		fields = append(fields, field)
	}
	if m.AvgStanceTime != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 91)
		field.Value = proto.Uint16(m.AvgStanceTime)
		fields = append(fields, field)
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 92)
		field.Value = proto.Uint8(m.AvgFractionalCadence)
		fields = append(fields, field)
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 93)
		field.Value = proto.Uint8(m.MaxFractionalCadence)
		fields = append(fields, field)
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 94)
		field.Value = proto.Uint8(m.TotalFractionalCycles)
		fields = append(fields, field)
	}
	if m.AvgTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 95)
		field.Value = proto.SliceUint16(m.AvgTotalHemoglobinConc)
		fields = append(fields, field)
	}
	if m.MinTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 96)
		field.Value = proto.SliceUint16(m.MinTotalHemoglobinConc)
		fields = append(fields, field)
	}
	if m.MaxTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 97)
		field.Value = proto.SliceUint16(m.MaxTotalHemoglobinConc)
		fields = append(fields, field)
	}
	if m.AvgSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 98)
		field.Value = proto.SliceUint16(m.AvgSaturatedHemoglobinPercent)
		fields = append(fields, field)
	}
	if m.MinSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 99)
		field.Value = proto.SliceUint16(m.MinSaturatedHemoglobinPercent)
		fields = append(fields, field)
	}
	if m.MaxSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 100)
		field.Value = proto.SliceUint16(m.MaxSaturatedHemoglobinPercent)
		fields = append(fields, field)
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 101)
		field.Value = proto.Uint8(m.AvgLeftTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 102)
		field.Value = proto.Uint8(m.AvgRightTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 103)
		field.Value = proto.Uint8(m.AvgLeftPedalSmoothness)
		fields = append(fields, field)
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 104)
		field.Value = proto.Uint8(m.AvgRightPedalSmoothness)
		fields = append(fields, field)
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 105)
		field.Value = proto.Uint8(m.AvgCombinedPedalSmoothness)
		fields = append(fields, field)
	}
	if m.SportProfileName != basetype.StringInvalid {
		field := fac.CreateField(mesg.Num, 110)
		field.Value = proto.String(m.SportProfileName)
		fields = append(fields, field)
	}
	if m.SportIndex != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 111)
		field.Value = proto.Uint8(m.SportIndex)
		fields = append(fields, field)
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 112)
		field.Value = proto.Uint32(m.TimeStanding)
		fields = append(fields, field)
	}
	if m.StandCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 113)
		field.Value = proto.Uint16(m.StandCount)
		fields = append(fields, field)
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 114)
		field.Value = proto.Int8(m.AvgLeftPco)
		fields = append(fields, field)
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 115)
		field.Value = proto.Int8(m.AvgRightPco)
		fields = append(fields, field)
	}
	if m.AvgLeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 116)
		field.Value = proto.SliceUint8(m.AvgLeftPowerPhase)
		fields = append(fields, field)
	}
	if m.AvgLeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 117)
		field.Value = proto.SliceUint8(m.AvgLeftPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.AvgRightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 118)
		field.Value = proto.SliceUint8(m.AvgRightPowerPhase)
		fields = append(fields, field)
	}
	if m.AvgRightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 119)
		field.Value = proto.SliceUint8(m.AvgRightPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.AvgPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 120)
		field.Value = proto.SliceUint16(m.AvgPowerPosition)
		fields = append(fields, field)
	}
	if m.MaxPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 121)
		field.Value = proto.SliceUint16(m.MaxPowerPosition)
		fields = append(fields, field)
	}
	if m.AvgCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 122)
		field.Value = proto.SliceUint8(m.AvgCadencePosition)
		fields = append(fields, field)
	}
	if m.MaxCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 123)
		field.Value = proto.SliceUint8(m.MaxCadencePosition)
		fields = append(fields, field)
	}
	if m.EnhancedAvgSpeed != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(124); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 124)
			field.Value = proto.Uint32(m.EnhancedAvgSpeed)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedMaxSpeed != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(125); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 125)
			field.Value = proto.Uint32(m.EnhancedMaxSpeed)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(126); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 126)
			field.Value = proto.Uint32(m.EnhancedAvgAltitude)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(127); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 127)
			field.Value = proto.Uint32(m.EnhancedMinAltitude)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(128); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 128)
			field.Value = proto.Uint32(m.EnhancedMaxAltitude)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.AvgLevMotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 129)
		field.Value = proto.Uint16(m.AvgLevMotorPower)
		fields = append(fields, field)
	}
	if m.MaxLevMotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 130)
		field.Value = proto.Uint16(m.MaxLevMotorPower)
		fields = append(fields, field)
	}
	if m.LevBatteryConsumption != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 131)
		field.Value = proto.Uint8(m.LevBatteryConsumption)
		fields = append(fields, field)
	}
	if m.AvgVerticalRatio != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 132)
		field.Value = proto.Uint16(m.AvgVerticalRatio)
		fields = append(fields, field)
	}
	if m.AvgStanceTimeBalance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 133)
		field.Value = proto.Uint16(m.AvgStanceTimeBalance)
		fields = append(fields, field)
	}
	if m.AvgStepLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 134)
		field.Value = proto.Uint16(m.AvgStepLength)
		fields = append(fields, field)
	}
	if m.TotalAnaerobicTrainingEffect != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 137)
		field.Value = proto.Uint8(m.TotalAnaerobicTrainingEffect)
		fields = append(fields, field)
	}
	if m.AvgVam != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 139)
		field.Value = proto.Uint16(m.AvgVam)
		fields = append(fields, field)
	}
	if m.AvgDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 140)
		field.Value = proto.Uint32(m.AvgDepth)
		fields = append(fields, field)
	}
	if m.MaxDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 141)
		field.Value = proto.Uint32(m.MaxDepth)
		fields = append(fields, field)
	}
	if m.SurfaceInterval != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 142)
		field.Value = proto.Uint32(m.SurfaceInterval)
		fields = append(fields, field)
	}
	if m.StartCns != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 143)
		field.Value = proto.Uint8(m.StartCns)
		fields = append(fields, field)
	}
	if m.EndCns != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 144)
		field.Value = proto.Uint8(m.EndCns)
		fields = append(fields, field)
	}
	if m.StartN2 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 145)
		field.Value = proto.Uint16(m.StartN2)
		fields = append(fields, field)
	}
	if m.EndN2 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 146)
		field.Value = proto.Uint16(m.EndN2)
		fields = append(fields, field)
	}
	if m.AvgRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 147)
		field.Value = proto.Uint8(m.AvgRespirationRate)
		fields = append(fields, field)
	}
	if m.MaxRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 148)
		field.Value = proto.Uint8(m.MaxRespirationRate)
		fields = append(fields, field)
	}
	if m.MinRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 149)
		field.Value = proto.Uint8(m.MinRespirationRate)
		fields = append(fields, field)
	}
	if m.MinTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 150)
		field.Value = proto.Int8(m.MinTemperature)
		fields = append(fields, field)
	}
	if m.O2Toxicity != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 155)
		field.Value = proto.Uint16(m.O2Toxicity)
		fields = append(fields, field)
	}
	if m.DiveNumber != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 156)
		field.Value = proto.Uint32(m.DiveNumber)
		fields = append(fields, field)
	}
	if m.TrainingLoadPeak != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 168)
		field.Value = proto.Int32(m.TrainingLoadPeak)
		fields = append(fields, field)
	}
	if m.EnhancedAvgRespirationRate != basetype.Uint16Invalid {
		if expanded := m.IsExpandedField(169); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 169)
			field.Value = proto.Uint16(m.EnhancedAvgRespirationRate)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedMaxRespirationRate != basetype.Uint16Invalid {
		if expanded := m.IsExpandedField(170); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 170)
			field.Value = proto.Uint16(m.EnhancedMaxRespirationRate)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedMinRespirationRate != basetype.Uint16Invalid {
		if expanded := m.IsExpandedField(180); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 180)
			field.Value = proto.Uint16(m.EnhancedMinRespirationRate)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if math.Float32bits(m.TotalGrit) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 181)
		field.Value = proto.Float32(m.TotalGrit)
		fields = append(fields, field)
	}
	if math.Float32bits(m.TotalFlow) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 182)
		field.Value = proto.Float32(m.TotalFlow)
		fields = append(fields, field)
	}
	if m.JumpCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 183)
		field.Value = proto.Uint16(m.JumpCount)
		fields = append(fields, field)
	}
	if math.Float32bits(m.AvgGrit) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 186)
		field.Value = proto.Float32(m.AvgGrit)
		fields = append(fields, field)
	}
	if math.Float32bits(m.AvgFlow) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 187)
		field.Value = proto.Float32(m.AvgFlow)
		fields = append(fields, field)
	}
	if m.WorkoutFeel != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 192)
		field.Value = proto.Uint8(m.WorkoutFeel)
		fields = append(fields, field)
	}
	if m.WorkoutRpe != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 193)
		field.Value = proto.Uint8(m.WorkoutRpe)
		fields = append(fields, field)
	}
	if m.AvgSpo2 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 194)
		field.Value = proto.Uint8(m.AvgSpo2)
		fields = append(fields, field)
	}
	if m.AvgStress != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 195)
		field.Value = proto.Uint8(m.AvgStress)
		fields = append(fields, field)
	}
	if m.SdrrHrv != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 197)
		field.Value = proto.Uint8(m.SdrrHrv)
		fields = append(fields, field)
	}
	if m.RmssdHrv != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 198)
		field.Value = proto.Uint8(m.RmssdHrv)
		fields = append(fields, field)
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 199)
		field.Value = proto.Uint8(m.TotalFractionalAscent)
		fields = append(fields, field)
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 200)
		field.Value = proto.Uint8(m.TotalFractionalDescent)
		fields = append(fields, field)
	}
	if m.AvgCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 208)
		field.Value = proto.Uint16(m.AvgCoreTemperature)
		fields = append(fields, field)
	}
	if m.MinCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 209)
		field.Value = proto.Uint16(m.MinCoreTemperature)
		fields = append(fields, field)
	}
	if m.MaxCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 210)
		field.Value = proto.Uint16(m.MaxCoreTemperature)
		fields = append(fields, field)
	}

	for i := range m.UnknownFields {
		fields = append(fields, m.UnknownFields[i])
	}

	mesg.Fields = make([]proto.Field, len(fields))
	copy(mesg.Fields, fields)
	*arr = [poolsize]proto.Field{}
	pool.Put(arr)

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// GetTotalCycles returns Dynamic Field interpretation of TotalCycles. Otherwise, returns the original value of TotalCycles.
//
// Based on m.Sport:
//   - name: "total_strides", units: "strides" , value: uint32(m.TotalCycles)
//   - name: "total_strokes", units: "strokes" , value: uint32(m.TotalCycles)
//
// Otherwise:
//   - name: "total_cycles", units: "cycles" , value: m.TotalCycles
func (m *Session) GetTotalCycles() (name string, value any) {
	switch m.Sport {
	case typedef.SportRunning, typedef.SportWalking:
		return "total_strides", uint32(m.TotalCycles)
	case typedef.SportCycling, typedef.SportSwimming, typedef.SportRowing, typedef.SportStandUpPaddleboarding:
		return "total_strokes", uint32(m.TotalCycles)
	}
	return "total_cycles", m.TotalCycles
}

// GetAvgCadence returns Dynamic Field interpretation of AvgCadence. Otherwise, returns the original value of AvgCadence.
//
// Based on m.Sport:
//   - name: "avg_running_cadence", units: "strides/min" , value: uint8(m.AvgCadence)
//
// Otherwise:
//   - name: "avg_cadence", units: "rpm" , value: m.AvgCadence
func (m *Session) GetAvgCadence() (name string, value any) {
	switch m.Sport {
	case typedef.SportRunning:
		return "avg_running_cadence", uint8(m.AvgCadence)
	}
	return "avg_cadence", m.AvgCadence
}

// GetMaxCadence returns Dynamic Field interpretation of MaxCadence. Otherwise, returns the original value of MaxCadence.
//
// Based on m.Sport:
//   - name: "max_running_cadence", units: "strides/min" , value: uint8(m.MaxCadence)
//
// Otherwise:
//   - name: "max_cadence", units: "rpm" , value: m.MaxCadence
func (m *Session) GetMaxCadence() (name string, value any) {
	switch m.Sport {
	case typedef.SportRunning:
		return "max_running_cadence", uint8(m.MaxCadence)
	}
	return "max_cadence", m.MaxCadence
}

// TimestampUint32 returns Timestamp in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *Session) TimestampUint32() uint32 { return datetime.ToUint32(m.Timestamp) }

// StartTimeUint32 returns StartTime in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *Session) StartTimeUint32() uint32 { return datetime.ToUint32(m.StartTime) }

// TotalElapsedTimeScaled return TotalElapsedTime in its scaled value.
// If TotalElapsedTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *Session) TotalElapsedTimeScaled() float64 {
	if m.TotalElapsedTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalElapsedTime)/1000 - 0
}

// TotalTimerTimeScaled return TotalTimerTime in its scaled value.
// If TotalTimerTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *Session) TotalTimerTimeScaled() float64 {
	if m.TotalTimerTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalTimerTime)/1000 - 0
}

// TotalDistanceScaled return TotalDistance in its scaled value.
// If TotalDistance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *Session) TotalDistanceScaled() float64 {
	if m.TotalDistance == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalDistance)/100 - 0
}

// AvgSpeedScaled return AvgSpeed in its scaled value.
// If AvgSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) AvgSpeedScaled() float64 {
	if m.AvgSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgSpeed)/1000 - 0
}

// MaxSpeedScaled return MaxSpeed in its scaled value.
// If MaxSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) MaxSpeedScaled() float64 {
	if m.MaxSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxSpeed)/1000 - 0
}

// TotalTrainingEffectScaled return TotalTrainingEffect in its scaled value.
// If TotalTrainingEffect value is invalid, float64 invalid value will be returned.
//
// Scale: 10
func (m *Session) TotalTrainingEffectScaled() float64 {
	if m.TotalTrainingEffect == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalTrainingEffect)/10 - 0
}

// TrainingStressScoreScaled return TrainingStressScore in its scaled value.
// If TrainingStressScore value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: tss
func (m *Session) TrainingStressScoreScaled() float64 {
	if m.TrainingStressScore == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TrainingStressScore)/10 - 0
}

// IntensityFactorScaled return IntensityFactor in its scaled value.
// If IntensityFactor value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: if
func (m *Session) IntensityFactorScaled() float64 {
	if m.IntensityFactor == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.IntensityFactor)/1000 - 0
}

// AvgStrokeCountScaled return AvgStrokeCount in its scaled value.
// If AvgStrokeCount value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: strokes/lap
func (m *Session) AvgStrokeCountScaled() float64 {
	if m.AvgStrokeCount == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStrokeCount)/10 - 0
}

// AvgStrokeDistanceScaled return AvgStrokeDistance in its scaled value.
// If AvgStrokeDistance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *Session) AvgStrokeDistanceScaled() float64 {
	if m.AvgStrokeDistance == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStrokeDistance)/100 - 0
}

// PoolLengthScaled return PoolLength in its scaled value.
// If PoolLength value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *Session) PoolLengthScaled() float64 {
	if m.PoolLength == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.PoolLength)/100 - 0
}

// AvgAltitudeScaled return AvgAltitude in its scaled value.
// If AvgAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) AvgAltitudeScaled() float64 {
	if m.AvgAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgAltitude)/5 - 500
}

// MaxAltitudeScaled return MaxAltitude in its scaled value.
// If MaxAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) MaxAltitudeScaled() float64 {
	if m.MaxAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxAltitude)/5 - 500
}

// AvgGradeScaled return AvgGrade in its scaled value.
// If AvgGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Session) AvgGradeScaled() float64 {
	if m.AvgGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgGrade)/100 - 0
}

// AvgPosGradeScaled return AvgPosGrade in its scaled value.
// If AvgPosGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Session) AvgPosGradeScaled() float64 {
	if m.AvgPosGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgPosGrade)/100 - 0
}

// AvgNegGradeScaled return AvgNegGrade in its scaled value.
// If AvgNegGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Session) AvgNegGradeScaled() float64 {
	if m.AvgNegGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgNegGrade)/100 - 0
}

// MaxPosGradeScaled return MaxPosGrade in its scaled value.
// If MaxPosGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Session) MaxPosGradeScaled() float64 {
	if m.MaxPosGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxPosGrade)/100 - 0
}

// MaxNegGradeScaled return MaxNegGrade in its scaled value.
// If MaxNegGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Session) MaxNegGradeScaled() float64 {
	if m.MaxNegGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxNegGrade)/100 - 0
}

// TotalMovingTimeScaled return TotalMovingTime in its scaled value.
// If TotalMovingTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s
func (m *Session) TotalMovingTimeScaled() float64 {
	if m.TotalMovingTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalMovingTime)/1000 - 0
}

// AvgPosVerticalSpeedScaled return AvgPosVerticalSpeed in its scaled value.
// If AvgPosVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) AvgPosVerticalSpeedScaled() float64 {
	if m.AvgPosVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgPosVerticalSpeed)/1000 - 0
}

// AvgNegVerticalSpeedScaled return AvgNegVerticalSpeed in its scaled value.
// If AvgNegVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) AvgNegVerticalSpeedScaled() float64 {
	if m.AvgNegVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgNegVerticalSpeed)/1000 - 0
}

// MaxPosVerticalSpeedScaled return MaxPosVerticalSpeed in its scaled value.
// If MaxPosVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) MaxPosVerticalSpeedScaled() float64 {
	if m.MaxPosVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxPosVerticalSpeed)/1000 - 0
}

// MaxNegVerticalSpeedScaled return MaxNegVerticalSpeed in its scaled value.
// If MaxNegVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) MaxNegVerticalSpeedScaled() float64 {
	if m.MaxNegVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxNegVerticalSpeed)/1000 - 0
}

// TimeInHrZoneScaled return TimeInHrZone in its scaled value.
// If TimeInHrZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) TimeInHrZoneScaled() []float64 {
	if m.TimeInHrZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInHrZone))
	for i := range m.TimeInHrZone {
		if m.TimeInHrZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInHrZone[i])/1000 - 0
	}
	return vals
}

// TimeInSpeedZoneScaled return TimeInSpeedZone in its scaled value.
// If TimeInSpeedZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) TimeInSpeedZoneScaled() []float64 {
	if m.TimeInSpeedZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInSpeedZone))
	for i := range m.TimeInSpeedZone {
		if m.TimeInSpeedZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInSpeedZone[i])/1000 - 0
	}
	return vals
}

// TimeInCadenceZoneScaled return TimeInCadenceZone in its scaled value.
// If TimeInCadenceZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) TimeInCadenceZoneScaled() []float64 {
	if m.TimeInCadenceZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInCadenceZone))
	for i := range m.TimeInCadenceZone {
		if m.TimeInCadenceZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInCadenceZone[i])/1000 - 0
	}
	return vals
}

// TimeInPowerZoneScaled return TimeInPowerZone in its scaled value.
// If TimeInPowerZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) TimeInPowerZoneScaled() []float64 {
	if m.TimeInPowerZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInPowerZone))
	for i := range m.TimeInPowerZone {
		if m.TimeInPowerZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInPowerZone[i])/1000 - 0
	}
	return vals
}

// AvgLapTimeScaled return AvgLapTime in its scaled value.
// If AvgLapTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s
func (m *Session) AvgLapTimeScaled() float64 {
	if m.AvgLapTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgLapTime)/1000 - 0
}

// MinAltitudeScaled return MinAltitude in its scaled value.
// If MinAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) MinAltitudeScaled() float64 {
	if m.MinAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MinAltitude)/5 - 500
}

// MaxBallSpeedScaled return MaxBallSpeed in its scaled value.
// If MaxBallSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m/s
func (m *Session) MaxBallSpeedScaled() float64 {
	if m.MaxBallSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxBallSpeed)/100 - 0
}

// AvgBallSpeedScaled return AvgBallSpeed in its scaled value.
// If AvgBallSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m/s
func (m *Session) AvgBallSpeedScaled() float64 {
	if m.AvgBallSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgBallSpeed)/100 - 0
}

// AvgVerticalOscillationScaled return AvgVerticalOscillation in its scaled value.
// If AvgVerticalOscillation value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: mm
func (m *Session) AvgVerticalOscillationScaled() float64 {
	if m.AvgVerticalOscillation == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgVerticalOscillation)/10 - 0
}

// AvgStanceTimePercentScaled return AvgStanceTimePercent in its scaled value.
// If AvgStanceTimePercent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Session) AvgStanceTimePercentScaled() float64 {
	if m.AvgStanceTimePercent == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStanceTimePercent)/100 - 0
}

// AvgStanceTimeScaled return AvgStanceTime in its scaled value.
// If AvgStanceTime value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: ms
func (m *Session) AvgStanceTimeScaled() float64 {
	if m.AvgStanceTime == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStanceTime)/10 - 0
}

// AvgFractionalCadenceScaled return AvgFractionalCadence in its scaled value.
// If AvgFractionalCadence value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *Session) AvgFractionalCadenceScaled() float64 {
	if m.AvgFractionalCadence == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgFractionalCadence)/128 - 0
}

// MaxFractionalCadenceScaled return MaxFractionalCadence in its scaled value.
// If MaxFractionalCadence value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *Session) MaxFractionalCadenceScaled() float64 {
	if m.MaxFractionalCadence == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxFractionalCadence)/128 - 0
}

// TotalFractionalCyclesScaled return TotalFractionalCycles in its scaled value.
// If TotalFractionalCycles value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *Session) TotalFractionalCyclesScaled() float64 {
	if m.TotalFractionalCycles == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalCycles)/128 - 0
}

// AvgTotalHemoglobinConcScaled return AvgTotalHemoglobinConc in its scaled value.
// If AvgTotalHemoglobinConc value is invalid, nil will be returned.
//
// Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
func (m *Session) AvgTotalHemoglobinConcScaled() []float64 {
	if m.AvgTotalHemoglobinConc == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgTotalHemoglobinConc))
	for i := range m.AvgTotalHemoglobinConc {
		if m.AvgTotalHemoglobinConc[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgTotalHemoglobinConc[i])/100 - 0
	}
	return vals
}

// MinTotalHemoglobinConcScaled return MinTotalHemoglobinConc in its scaled value.
// If MinTotalHemoglobinConc value is invalid, nil will be returned.
//
// Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Session) MinTotalHemoglobinConcScaled() []float64 {
	if m.MinTotalHemoglobinConc == nil {
		return nil
	}
	var vals = make([]float64, len(m.MinTotalHemoglobinConc))
	for i := range m.MinTotalHemoglobinConc {
		if m.MinTotalHemoglobinConc[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.MinTotalHemoglobinConc[i])/100 - 0
	}
	return vals
}

// MaxTotalHemoglobinConcScaled return MaxTotalHemoglobinConc in its scaled value.
// If MaxTotalHemoglobinConc value is invalid, nil will be returned.
//
// Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Session) MaxTotalHemoglobinConcScaled() []float64 {
	if m.MaxTotalHemoglobinConc == nil {
		return nil
	}
	var vals = make([]float64, len(m.MaxTotalHemoglobinConc))
	for i := range m.MaxTotalHemoglobinConc {
		if m.MaxTotalHemoglobinConc[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.MaxTotalHemoglobinConc[i])/100 - 0
	}
	return vals
}

// AvgSaturatedHemoglobinPercentScaled return AvgSaturatedHemoglobinPercent in its scaled value.
// If AvgSaturatedHemoglobinPercent value is invalid, nil will be returned.
//
// Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
func (m *Session) AvgSaturatedHemoglobinPercentScaled() []float64 {
	if m.AvgSaturatedHemoglobinPercent == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgSaturatedHemoglobinPercent))
	for i := range m.AvgSaturatedHemoglobinPercent {
		if m.AvgSaturatedHemoglobinPercent[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgSaturatedHemoglobinPercent[i])/10 - 0
	}
	return vals
}

// MinSaturatedHemoglobinPercentScaled return MinSaturatedHemoglobinPercent in its scaled value.
// If MinSaturatedHemoglobinPercent value is invalid, nil will be returned.
//
// Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Session) MinSaturatedHemoglobinPercentScaled() []float64 {
	if m.MinSaturatedHemoglobinPercent == nil {
		return nil
	}
	var vals = make([]float64, len(m.MinSaturatedHemoglobinPercent))
	for i := range m.MinSaturatedHemoglobinPercent {
		if m.MinSaturatedHemoglobinPercent[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.MinSaturatedHemoglobinPercent[i])/10 - 0
	}
	return vals
}

// MaxSaturatedHemoglobinPercentScaled return MaxSaturatedHemoglobinPercent in its scaled value.
// If MaxSaturatedHemoglobinPercent value is invalid, nil will be returned.
//
// Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Session) MaxSaturatedHemoglobinPercentScaled() []float64 {
	if m.MaxSaturatedHemoglobinPercent == nil {
		return nil
	}
	var vals = make([]float64, len(m.MaxSaturatedHemoglobinPercent))
	for i := range m.MaxSaturatedHemoglobinPercent {
		if m.MaxSaturatedHemoglobinPercent[i] == basetype.Uint16Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.MaxSaturatedHemoglobinPercent[i])/10 - 0
	}
	return vals
}

// AvgLeftTorqueEffectivenessScaled return AvgLeftTorqueEffectiveness in its scaled value.
// If AvgLeftTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Session) AvgLeftTorqueEffectivenessScaled() float64 {
	if m.AvgLeftTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgLeftTorqueEffectiveness)/2 - 0
}

// AvgRightTorqueEffectivenessScaled return AvgRightTorqueEffectiveness in its scaled value.
// If AvgRightTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Session) AvgRightTorqueEffectivenessScaled() float64 {
	if m.AvgRightTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgRightTorqueEffectiveness)/2 - 0
}

// AvgLeftPedalSmoothnessScaled return AvgLeftPedalSmoothness in its scaled value.
// If AvgLeftPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Session) AvgLeftPedalSmoothnessScaled() float64 {
	if m.AvgLeftPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgLeftPedalSmoothness)/2 - 0
}

// AvgRightPedalSmoothnessScaled return AvgRightPedalSmoothness in its scaled value.
// If AvgRightPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Session) AvgRightPedalSmoothnessScaled() float64 {
	if m.AvgRightPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgRightPedalSmoothness)/2 - 0
}

// AvgCombinedPedalSmoothnessScaled return AvgCombinedPedalSmoothness in its scaled value.
// If AvgCombinedPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Session) AvgCombinedPedalSmoothnessScaled() float64 {
	if m.AvgCombinedPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgCombinedPedalSmoothness)/2 - 0
}

// TimeStandingScaled return TimeStanding in its scaled value.
// If TimeStanding value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Total time spend in the standing position
func (m *Session) TimeStandingScaled() float64 {
	if m.TimeStanding == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TimeStanding)/1000 - 0
}

// AvgLeftPowerPhaseScaled return AvgLeftPowerPhase in its scaled value.
// If AvgLeftPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
func (m *Session) AvgLeftPowerPhaseScaled() []float64 {
	if m.AvgLeftPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgLeftPowerPhase))
	for i := range m.AvgLeftPowerPhase {
		if m.AvgLeftPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgLeftPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// AvgLeftPowerPhasePeakScaled return AvgLeftPowerPhasePeak in its scaled value.
// If AvgLeftPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Session) AvgLeftPowerPhasePeakScaled() []float64 {
	if m.AvgLeftPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgLeftPowerPhasePeak))
	for i := range m.AvgLeftPowerPhasePeak {
		if m.AvgLeftPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgLeftPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// AvgRightPowerPhaseScaled return AvgRightPowerPhase in its scaled value.
// If AvgRightPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *Session) AvgRightPowerPhaseScaled() []float64 {
	if m.AvgRightPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgRightPowerPhase))
	for i := range m.AvgRightPowerPhase {
		if m.AvgRightPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgRightPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// AvgRightPowerPhasePeakScaled return AvgRightPowerPhasePeak in its scaled value.
// If AvgRightPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
func (m *Session) AvgRightPowerPhasePeakScaled() []float64 {
	if m.AvgRightPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgRightPowerPhasePeak))
	for i := range m.AvgRightPowerPhasePeak {
		if m.AvgRightPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgRightPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// EnhancedAvgSpeedScaled return EnhancedAvgSpeed in its scaled value.
// If EnhancedAvgSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) EnhancedAvgSpeedScaled() float64 {
	if m.EnhancedAvgSpeed == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedAvgSpeed)/1000 - 0
}

// EnhancedMaxSpeedScaled return EnhancedMaxSpeed in its scaled value.
// If EnhancedMaxSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) EnhancedMaxSpeedScaled() float64 {
	if m.EnhancedMaxSpeed == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMaxSpeed)/1000 - 0
}

// EnhancedAvgAltitudeScaled return EnhancedAvgAltitude in its scaled value.
// If EnhancedAvgAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) EnhancedAvgAltitudeScaled() float64 {
	if m.EnhancedAvgAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedAvgAltitude)/5 - 500
}

// EnhancedMinAltitudeScaled return EnhancedMinAltitude in its scaled value.
// If EnhancedMinAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) EnhancedMinAltitudeScaled() float64 {
	if m.EnhancedMinAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMinAltitude)/5 - 500
}

// EnhancedMaxAltitudeScaled return EnhancedMaxAltitude in its scaled value.
// If EnhancedMaxAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) EnhancedMaxAltitudeScaled() float64 {
	if m.EnhancedMaxAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMaxAltitude)/5 - 500
}

// LevBatteryConsumptionScaled return LevBatteryConsumption in its scaled value.
// If LevBatteryConsumption value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent; lev battery consumption during session
func (m *Session) LevBatteryConsumptionScaled() float64 {
	if m.LevBatteryConsumption == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.LevBatteryConsumption)/2 - 0
}

// AvgVerticalRatioScaled return AvgVerticalRatio in its scaled value.
// If AvgVerticalRatio value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Session) AvgVerticalRatioScaled() float64 {
	if m.AvgVerticalRatio == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgVerticalRatio)/100 - 0
}

// AvgStanceTimeBalanceScaled return AvgStanceTimeBalance in its scaled value.
// If AvgStanceTimeBalance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Session) AvgStanceTimeBalanceScaled() float64 {
	if m.AvgStanceTimeBalance == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStanceTimeBalance)/100 - 0
}

// AvgStepLengthScaled return AvgStepLength in its scaled value.
// If AvgStepLength value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: mm
func (m *Session) AvgStepLengthScaled() float64 {
	if m.AvgStepLength == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgStepLength)/10 - 0
}

// TotalAnaerobicTrainingEffectScaled return TotalAnaerobicTrainingEffect in its scaled value.
// If TotalAnaerobicTrainingEffect value is invalid, float64 invalid value will be returned.
//
// Scale: 10
func (m *Session) TotalAnaerobicTrainingEffectScaled() float64 {
	if m.TotalAnaerobicTrainingEffect == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalAnaerobicTrainingEffect)/10 - 0
}

// AvgVamScaled return AvgVam in its scaled value.
// If AvgVam value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Session) AvgVamScaled() float64 {
	if m.AvgVam == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgVam)/1000 - 0
}

// AvgDepthScaled return AvgDepth in its scaled value.
// If AvgDepth value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) AvgDepthScaled() float64 {
	if m.AvgDepth == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgDepth)/1000 - 0
}

// MaxDepthScaled return MaxDepth in its scaled value.
// If MaxDepth value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) MaxDepthScaled() float64 {
	if m.MaxDepth == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxDepth)/1000 - 0
}

// TrainingLoadPeakScaled return TrainingLoadPeak in its scaled value.
// If TrainingLoadPeak value is invalid, float64 invalid value will be returned.
//
// Scale: 65536
func (m *Session) TrainingLoadPeakScaled() float64 {
	if m.TrainingLoadPeak == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TrainingLoadPeak)/65536 - 0
}

// EnhancedAvgRespirationRateScaled return EnhancedAvgRespirationRate in its scaled value.
// If EnhancedAvgRespirationRate value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: Breaths/min
func (m *Session) EnhancedAvgRespirationRateScaled() float64 {
	if m.EnhancedAvgRespirationRate == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedAvgRespirationRate)/100 - 0
}

// EnhancedMaxRespirationRateScaled return EnhancedMaxRespirationRate in its scaled value.
// If EnhancedMaxRespirationRate value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: Breaths/min
func (m *Session) EnhancedMaxRespirationRateScaled() float64 {
	if m.EnhancedMaxRespirationRate == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMaxRespirationRate)/100 - 0
}

// EnhancedMinRespirationRateScaled return EnhancedMinRespirationRate in its scaled value.
// If EnhancedMinRespirationRate value is invalid, float64 invalid value will be returned.
//
// Scale: 100
func (m *Session) EnhancedMinRespirationRateScaled() float64 {
	if m.EnhancedMinRespirationRate == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMinRespirationRate)/100 - 0
}

// TotalFractionalAscentScaled return TotalFractionalAscent in its scaled value.
// If TotalFractionalAscent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *Session) TotalFractionalAscentScaled() float64 {
	if m.TotalFractionalAscent == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalAscent)/100 - 0
}

// TotalFractionalDescentScaled return TotalFractionalDescent in its scaled value.
// If TotalFractionalDescent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *Session) TotalFractionalDescentScaled() float64 {
	if m.TotalFractionalDescent == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalDescent)/100 - 0
}

// AvgCoreTemperatureScaled return AvgCoreTemperature in its scaled value.
// If AvgCoreTemperature value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: C
func (m *Session) AvgCoreTemperatureScaled() float64 {
	if m.AvgCoreTemperature == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgCoreTemperature)/100 - 0
}

// MinCoreTemperatureScaled return MinCoreTemperature in its scaled value.
// If MinCoreTemperature value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: C
func (m *Session) MinCoreTemperatureScaled() float64 {
	if m.MinCoreTemperature == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MinCoreTemperature)/100 - 0
}

// MaxCoreTemperatureScaled return MaxCoreTemperature in its scaled value.
// If MaxCoreTemperature value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: C
func (m *Session) MaxCoreTemperatureScaled() float64 {
	if m.MaxCoreTemperature == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxCoreTemperature)/100 - 0
}

// StartPositionLatDegrees returns StartPositionLat in degrees instead of semicircles.
// If StartPositionLat value is invalid, float64 invalid value will be returned.
func (m *Session) StartPositionLatDegrees() float64 {
	return semicircles.ToDegrees(m.StartPositionLat)
}

// StartPositionLongDegrees returns StartPositionLong in degrees instead of semicircles.
// If StartPositionLong value is invalid, float64 invalid value will be returned.
func (m *Session) StartPositionLongDegrees() float64 {
	return semicircles.ToDegrees(m.StartPositionLong)
}

// NecLatDegrees returns NecLat in degrees instead of semicircles.
// If NecLat value is invalid, float64 invalid value will be returned.
func (m *Session) NecLatDegrees() float64 {
	return semicircles.ToDegrees(m.NecLat)
}

// NecLongDegrees returns NecLong in degrees instead of semicircles.
// If NecLong value is invalid, float64 invalid value will be returned.
func (m *Session) NecLongDegrees() float64 {
	return semicircles.ToDegrees(m.NecLong)
}

// SwcLatDegrees returns SwcLat in degrees instead of semicircles.
// If SwcLat value is invalid, float64 invalid value will be returned.
func (m *Session) SwcLatDegrees() float64 {
	return semicircles.ToDegrees(m.SwcLat)
}

// SwcLongDegrees returns SwcLong in degrees instead of semicircles.
// If SwcLong value is invalid, float64 invalid value will be returned.
func (m *Session) SwcLongDegrees() float64 {
	return semicircles.ToDegrees(m.SwcLong)
}

// EndPositionLatDegrees returns EndPositionLat in degrees instead of semicircles.
// If EndPositionLat value is invalid, float64 invalid value will be returned.
func (m *Session) EndPositionLatDegrees() float64 {
	return semicircles.ToDegrees(m.EndPositionLat)
}

// EndPositionLongDegrees returns EndPositionLong in degrees instead of semicircles.
// If EndPositionLong value is invalid, float64 invalid value will be returned.
func (m *Session) EndPositionLongDegrees() float64 {
	return semicircles.ToDegrees(m.EndPositionLong)
}

// SetMessageIndex sets MessageIndex value.
//
// Selected bit is set for the current session.
func (m *Session) SetMessageIndex(v typedef.MessageIndex) *Session {
	m.MessageIndex = v
	return m
}

// SetTimestamp sets Timestamp value.
//
// Units: s; Sesson end time.
func (m *Session) SetTimestamp(v time.Time) *Session {
	m.Timestamp = v
	return m
}

// SetEvent sets Event value.
//
// session
func (m *Session) SetEvent(v typedef.Event) *Session {
	m.Event = v
	return m
}

// SetEventType sets EventType value.
//
// stop
func (m *Session) SetEventType(v typedef.EventType) *Session {
	m.EventType = v
	return m
}

// SetStartTime sets StartTime value.
func (m *Session) SetStartTime(v time.Time) *Session {
	m.StartTime = v
	return m
}

// SetStartPositionLat sets StartPositionLat value.
//
// Units: semicircles
func (m *Session) SetStartPositionLat(v int32) *Session {
	m.StartPositionLat = v
	return m
}

// SetStartPositionLatDegrees is similar to SetStartPositionLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetStartPositionLatDegrees(degrees float64) *Session {
	m.StartPositionLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetStartPositionLong sets StartPositionLong value.
//
// Units: semicircles
func (m *Session) SetStartPositionLong(v int32) *Session {
	m.StartPositionLong = v
	return m
}

// SetStartPositionLongDegrees is similar to SetStartPositionLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetStartPositionLongDegrees(degrees float64) *Session {
	m.StartPositionLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetSport sets Sport value.
func (m *Session) SetSport(v typedef.Sport) *Session {
	m.Sport = v
	return m
}

// SetSubSport sets SubSport value.
func (m *Session) SetSubSport(v typedef.SubSport) *Session {
	m.SubSport = v
	return m
}

// SetTotalElapsedTime sets TotalElapsedTime value.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *Session) SetTotalElapsedTime(v uint32) *Session {
	m.TotalElapsedTime = v
	return m
}

// SetTotalElapsedTimeScaled is similar to SetTotalElapsedTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *Session) SetTotalElapsedTimeScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalElapsedTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalElapsedTime = uint32(unscaled)
	return m
}

// SetTotalTimerTime sets TotalTimerTime value.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *Session) SetTotalTimerTime(v uint32) *Session {
	m.TotalTimerTime = v
	return m
}

// SetTotalTimerTimeScaled is similar to SetTotalTimerTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *Session) SetTotalTimerTimeScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalTimerTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalTimerTime = uint32(unscaled)
	return m
}

// SetTotalDistance sets TotalDistance value.
//
// Scale: 100; Units: m
func (m *Session) SetTotalDistance(v uint32) *Session {
	m.TotalDistance = v
	return m
}

// SetTotalDistanceScaled is similar to SetTotalDistance except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *Session) SetTotalDistanceScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalDistance = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalDistance = uint32(unscaled)
	return m
}

// SetTotalCycles sets TotalCycles value.
//
// Units: cycles
func (m *Session) SetTotalCycles(v uint32) *Session {
	m.TotalCycles = v
	return m
}

// SetTotalCalories sets TotalCalories value.
//
// Units: kcal
func (m *Session) SetTotalCalories(v uint16) *Session {
	m.TotalCalories = v
	return m
}

// SetTotalFatCalories sets TotalFatCalories value.
//
// Units: kcal
func (m *Session) SetTotalFatCalories(v uint16) *Session {
	m.TotalFatCalories = v
	return m
}

// SetAvgSpeed sets AvgSpeed value.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetAvgSpeed(v uint16) *Session {
	m.AvgSpeed = v
	return m
}

// SetAvgSpeedScaled is similar to SetAvgSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetAvgSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgSpeed = uint16(unscaled)
	return m
}

// SetMaxSpeed sets MaxSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxSpeed(v uint16) *Session {
	m.MaxSpeed = v
	return m
}

// SetMaxSpeedScaled is similar to SetMaxSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxSpeed = uint16(unscaled)
	return m
}

// SetAvgHeartRate sets AvgHeartRate value.
//
// Units: bpm; average heart rate (excludes pause time)
func (m *Session) SetAvgHeartRate(v uint8) *Session {
	m.AvgHeartRate = v
	return m
}

// SetMaxHeartRate sets MaxHeartRate value.
//
// Units: bpm
func (m *Session) SetMaxHeartRate(v uint8) *Session {
	m.MaxHeartRate = v
	return m
}

// SetAvgCadence sets AvgCadence value.
//
// Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
func (m *Session) SetAvgCadence(v uint8) *Session {
	m.AvgCadence = v
	return m
}

// SetMaxCadence sets MaxCadence value.
//
// Units: rpm
func (m *Session) SetMaxCadence(v uint8) *Session {
	m.MaxCadence = v
	return m
}

// SetAvgPower sets AvgPower value.
//
// Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
func (m *Session) SetAvgPower(v uint16) *Session {
	m.AvgPower = v
	return m
}

// SetMaxPower sets MaxPower value.
//
// Units: watts
func (m *Session) SetMaxPower(v uint16) *Session {
	m.MaxPower = v
	return m
}

// SetTotalAscent sets TotalAscent value.
//
// Units: m
func (m *Session) SetTotalAscent(v uint16) *Session {
	m.TotalAscent = v
	return m
}

// SetTotalDescent sets TotalDescent value.
//
// Units: m
func (m *Session) SetTotalDescent(v uint16) *Session {
	m.TotalDescent = v
	return m
}

// SetTotalTrainingEffect sets TotalTrainingEffect value.
//
// Scale: 10
func (m *Session) SetTotalTrainingEffect(v uint8) *Session {
	m.TotalTrainingEffect = v
	return m
}

// SetTotalTrainingEffectScaled is similar to SetTotalTrainingEffect except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 10
func (m *Session) SetTotalTrainingEffectScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalTrainingEffect = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalTrainingEffect = uint8(unscaled)
	return m
}

// SetFirstLapIndex sets FirstLapIndex value.
func (m *Session) SetFirstLapIndex(v uint16) *Session {
	m.FirstLapIndex = v
	return m
}

// SetNumLaps sets NumLaps value.
func (m *Session) SetNumLaps(v uint16) *Session {
	m.NumLaps = v
	return m
}

// SetEventGroup sets EventGroup value.
func (m *Session) SetEventGroup(v uint8) *Session {
	m.EventGroup = v
	return m
}

// SetTrigger sets Trigger value.
func (m *Session) SetTrigger(v typedef.SessionTrigger) *Session {
	m.Trigger = v
	return m
}

// SetNecLat sets NecLat value.
//
// Units: semicircles; North east corner latitude
func (m *Session) SetNecLat(v int32) *Session {
	m.NecLat = v
	return m
}

// SetNecLatDegrees is similar to SetNecLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetNecLatDegrees(degrees float64) *Session {
	m.NecLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetNecLong sets NecLong value.
//
// Units: semicircles; North east corner longitude
func (m *Session) SetNecLong(v int32) *Session {
	m.NecLong = v
	return m
}

// SetNecLongDegrees is similar to SetNecLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetNecLongDegrees(degrees float64) *Session {
	m.NecLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetSwcLat sets SwcLat value.
//
// Units: semicircles; South west corner latitude
func (m *Session) SetSwcLat(v int32) *Session {
	m.SwcLat = v
	return m
}

// SetSwcLatDegrees is similar to SetSwcLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetSwcLatDegrees(degrees float64) *Session {
	m.SwcLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetSwcLong sets SwcLong value.
//
// Units: semicircles; South west corner longitude
func (m *Session) SetSwcLong(v int32) *Session {
	m.SwcLong = v
	return m
}

// SetSwcLongDegrees is similar to SetSwcLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetSwcLongDegrees(degrees float64) *Session {
	m.SwcLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetNumLengths sets NumLengths value.
//
// Units: lengths; # of lengths of swim pool
func (m *Session) SetNumLengths(v uint16) *Session {
	m.NumLengths = v
	return m
}

// SetNormalizedPower sets NormalizedPower value.
//
// Units: watts
func (m *Session) SetNormalizedPower(v uint16) *Session {
	m.NormalizedPower = v
	return m
}

// SetTrainingStressScore sets TrainingStressScore value.
//
// Scale: 10; Units: tss
func (m *Session) SetTrainingStressScore(v uint16) *Session {
	m.TrainingStressScore = v
	return m
}

// SetTrainingStressScoreScaled is similar to SetTrainingStressScore except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: tss
func (m *Session) SetTrainingStressScoreScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.TrainingStressScore = uint16(basetype.Uint16Invalid)
		return m
	}
	m.TrainingStressScore = uint16(unscaled)
	return m
}

// SetIntensityFactor sets IntensityFactor value.
//
// Scale: 1000; Units: if
func (m *Session) SetIntensityFactor(v uint16) *Session {
	m.IntensityFactor = v
	return m
}

// SetIntensityFactorScaled is similar to SetIntensityFactor except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: if
func (m *Session) SetIntensityFactorScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.IntensityFactor = uint16(basetype.Uint16Invalid)
		return m
	}
	m.IntensityFactor = uint16(unscaled)
	return m
}

// SetLeftRightBalance sets LeftRightBalance value.
func (m *Session) SetLeftRightBalance(v typedef.LeftRightBalance100) *Session {
	m.LeftRightBalance = v
	return m
}

// SetEndPositionLat sets EndPositionLat value.
//
// Units: semicircles
func (m *Session) SetEndPositionLat(v int32) *Session {
	m.EndPositionLat = v
	return m
}

// SetEndPositionLatDegrees is similar to SetEndPositionLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetEndPositionLatDegrees(degrees float64) *Session {
	m.EndPositionLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetEndPositionLong sets EndPositionLong value.
//
// Units: semicircles
func (m *Session) SetEndPositionLong(v int32) *Session {
	m.EndPositionLong = v
	return m
}

// SetEndPositionLongDegrees is similar to SetEndPositionLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Session) SetEndPositionLongDegrees(degrees float64) *Session {
	m.EndPositionLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetAvgStrokeCount sets AvgStrokeCount value.
//
// Scale: 10; Units: strokes/lap
func (m *Session) SetAvgStrokeCount(v uint32) *Session {
	m.AvgStrokeCount = v
	return m
}

// SetAvgStrokeCountScaled is similar to SetAvgStrokeCount except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 10; Units: strokes/lap
func (m *Session) SetAvgStrokeCountScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.AvgStrokeCount = uint32(basetype.Uint32Invalid)
		return m
	}
	m.AvgStrokeCount = uint32(unscaled)
	return m
}

// SetAvgStrokeDistance sets AvgStrokeDistance value.
//
// Scale: 100; Units: m
func (m *Session) SetAvgStrokeDistance(v uint16) *Session {
	m.AvgStrokeDistance = v
	return m
}

// SetAvgStrokeDistanceScaled is similar to SetAvgStrokeDistance except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *Session) SetAvgStrokeDistanceScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgStrokeDistance = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgStrokeDistance = uint16(unscaled)
	return m
}

// SetSwimStroke sets SwimStroke value.
//
// Units: swim_stroke
func (m *Session) SetSwimStroke(v typedef.SwimStroke) *Session {
	m.SwimStroke = v
	return m
}

// SetPoolLength sets PoolLength value.
//
// Scale: 100; Units: m
func (m *Session) SetPoolLength(v uint16) *Session {
	m.PoolLength = v
	return m
}

// SetPoolLengthScaled is similar to SetPoolLength except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *Session) SetPoolLengthScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.PoolLength = uint16(basetype.Uint16Invalid)
		return m
	}
	m.PoolLength = uint16(unscaled)
	return m
}

// SetThresholdPower sets ThresholdPower value.
//
// Units: watts
func (m *Session) SetThresholdPower(v uint16) *Session {
	m.ThresholdPower = v
	return m
}

// SetPoolLengthUnit sets PoolLengthUnit value.
func (m *Session) SetPoolLengthUnit(v typedef.DisplayMeasure) *Session {
	m.PoolLengthUnit = v
	return m
}

// SetNumActiveLengths sets NumActiveLengths value.
//
// Units: lengths; # of active lengths of swim pool
func (m *Session) SetNumActiveLengths(v uint16) *Session {
	m.NumActiveLengths = v
	return m
}

// SetTotalWork sets TotalWork value.
//
// Units: J
func (m *Session) SetTotalWork(v uint32) *Session {
	m.TotalWork = v
	return m
}

// SetAvgAltitude sets AvgAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetAvgAltitude(v uint16) *Session {
	m.AvgAltitude = v
	return m
}

// SetAvgAltitudeScaled is similar to SetAvgAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetAvgAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgAltitude = uint16(unscaled)
	return m
}

// SetMaxAltitude sets MaxAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetMaxAltitude(v uint16) *Session {
	m.MaxAltitude = v
	return m
}

// SetMaxAltitudeScaled is similar to SetMaxAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetMaxAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxAltitude = uint16(unscaled)
	return m
}

// SetGpsAccuracy sets GpsAccuracy value.
//
// Units: m
func (m *Session) SetGpsAccuracy(v uint8) *Session {
	m.GpsAccuracy = v
	return m
}

// SetAvgGrade sets AvgGrade value.
//
// Scale: 100; Units: %
func (m *Session) SetAvgGrade(v int16) *Session {
	m.AvgGrade = v
	return m
}

// SetAvgGradeScaled is similar to SetAvgGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Session) SetAvgGradeScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgGrade = int16(unscaled)
	return m
}

// SetAvgPosGrade sets AvgPosGrade value.
//
// Scale: 100; Units: %
func (m *Session) SetAvgPosGrade(v int16) *Session {
	m.AvgPosGrade = v
	return m
}

// SetAvgPosGradeScaled is similar to SetAvgPosGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Session) SetAvgPosGradeScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgPosGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgPosGrade = int16(unscaled)
	return m
}

// SetAvgNegGrade sets AvgNegGrade value.
//
// Scale: 100; Units: %
func (m *Session) SetAvgNegGrade(v int16) *Session {
	m.AvgNegGrade = v
	return m
}

// SetAvgNegGradeScaled is similar to SetAvgNegGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Session) SetAvgNegGradeScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgNegGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgNegGrade = int16(unscaled)
	return m
}

// SetMaxPosGrade sets MaxPosGrade value.
//
// Scale: 100; Units: %
func (m *Session) SetMaxPosGrade(v int16) *Session {
	m.MaxPosGrade = v
	return m
}

// SetMaxPosGradeScaled is similar to SetMaxPosGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Session) SetMaxPosGradeScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxPosGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxPosGrade = int16(unscaled)
	return m
}

// SetMaxNegGrade sets MaxNegGrade value.
//
// Scale: 100; Units: %
func (m *Session) SetMaxNegGrade(v int16) *Session {
	m.MaxNegGrade = v
	return m
}

// SetMaxNegGradeScaled is similar to SetMaxNegGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Session) SetMaxNegGradeScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxNegGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxNegGrade = int16(unscaled)
	return m
}

// SetAvgTemperature sets AvgTemperature value.
//
// Units: C
func (m *Session) SetAvgTemperature(v int8) *Session {
	m.AvgTemperature = v
	return m
}

// SetMaxTemperature sets MaxTemperature value.
//
// Units: C
func (m *Session) SetMaxTemperature(v int8) *Session {
	m.MaxTemperature = v
	return m
}

// SetTotalMovingTime sets TotalMovingTime value.
//
// Scale: 1000; Units: s
func (m *Session) SetTotalMovingTime(v uint32) *Session {
	m.TotalMovingTime = v
	return m
}

// SetTotalMovingTimeScaled is similar to SetTotalMovingTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s
func (m *Session) SetTotalMovingTimeScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalMovingTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalMovingTime = uint32(unscaled)
	return m
}

// SetAvgPosVerticalSpeed sets AvgPosVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgPosVerticalSpeed(v int16) *Session {
	m.AvgPosVerticalSpeed = v
	return m
}

// SetAvgPosVerticalSpeedScaled is similar to SetAvgPosVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgPosVerticalSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgPosVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgPosVerticalSpeed = int16(unscaled)
	return m
}

// SetAvgNegVerticalSpeed sets AvgNegVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgNegVerticalSpeed(v int16) *Session {
	m.AvgNegVerticalSpeed = v
	return m
}

// SetAvgNegVerticalSpeedScaled is similar to SetAvgNegVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgNegVerticalSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgNegVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgNegVerticalSpeed = int16(unscaled)
	return m
}

// SetMaxPosVerticalSpeed sets MaxPosVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxPosVerticalSpeed(v int16) *Session {
	m.MaxPosVerticalSpeed = v
	return m
}

// SetMaxPosVerticalSpeedScaled is similar to SetMaxPosVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxPosVerticalSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxPosVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxPosVerticalSpeed = int16(unscaled)
	return m
}

// SetMaxNegVerticalSpeed sets MaxNegVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxNegVerticalSpeed(v int16) *Session {
	m.MaxNegVerticalSpeed = v
	return m
}

// SetMaxNegVerticalSpeedScaled is similar to SetMaxNegVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetMaxNegVerticalSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxNegVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxNegVerticalSpeed = int16(unscaled)
	return m
}

// SetMinHeartRate sets MinHeartRate value.
//
// Units: bpm
func (m *Session) SetMinHeartRate(v uint8) *Session {
	m.MinHeartRate = v
	return m
}

// SetTimeInHrZone sets TimeInHrZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInHrZone(v []uint32) *Session {
	m.TimeInHrZone = v
	return m
}

// SetTimeInHrZoneScaled is similar to SetTimeInHrZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInHrZoneScaled(vs []float64) *Session {
	if vs == nil {
		m.TimeInHrZone = nil
		return m
	}
	m.TimeInHrZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInHrZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInHrZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInSpeedZone sets TimeInSpeedZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInSpeedZone(v []uint32) *Session {
	m.TimeInSpeedZone = v
	return m
}

// SetTimeInSpeedZoneScaled is similar to SetTimeInSpeedZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInSpeedZoneScaled(vs []float64) *Session {
	if vs == nil {
		m.TimeInSpeedZone = nil
		return m
	}
	m.TimeInSpeedZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInSpeedZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInSpeedZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInCadenceZone sets TimeInCadenceZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInCadenceZone(v []uint32) *Session {
	m.TimeInCadenceZone = v
	return m
}

// SetTimeInCadenceZoneScaled is similar to SetTimeInCadenceZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInCadenceZoneScaled(vs []float64) *Session {
	if vs == nil {
		m.TimeInCadenceZone = nil
		return m
	}
	m.TimeInCadenceZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInCadenceZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInCadenceZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInPowerZone sets TimeInPowerZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInPowerZone(v []uint32) *Session {
	m.TimeInPowerZone = v
	return m
}

// SetTimeInPowerZoneScaled is similar to SetTimeInPowerZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *Session) SetTimeInPowerZoneScaled(vs []float64) *Session {
	if vs == nil {
		m.TimeInPowerZone = nil
		return m
	}
	m.TimeInPowerZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInPowerZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInPowerZone[i] = uint32(unscaled)
	}
	return m
}

// SetAvgLapTime sets AvgLapTime value.
//
// Scale: 1000; Units: s
func (m *Session) SetAvgLapTime(v uint32) *Session {
	m.AvgLapTime = v
	return m
}

// SetAvgLapTimeScaled is similar to SetAvgLapTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s
func (m *Session) SetAvgLapTimeScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.AvgLapTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.AvgLapTime = uint32(unscaled)
	return m
}

// SetBestLapIndex sets BestLapIndex value.
func (m *Session) SetBestLapIndex(v uint16) *Session {
	m.BestLapIndex = v
	return m
}

// SetMinAltitude sets MinAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetMinAltitude(v uint16) *Session {
	m.MinAltitude = v
	return m
}

// SetMinAltitudeScaled is similar to SetMinAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetMinAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MinAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MinAltitude = uint16(unscaled)
	return m
}

// SetPlayerScore sets PlayerScore value.
func (m *Session) SetPlayerScore(v uint16) *Session {
	m.PlayerScore = v
	return m
}

// SetOpponentScore sets OpponentScore value.
func (m *Session) SetOpponentScore(v uint16) *Session {
	m.OpponentScore = v
	return m
}

// SetOpponentName sets OpponentName value.
func (m *Session) SetOpponentName(v string) *Session {
	m.OpponentName = v
	return m
}

// SetStrokeCount sets StrokeCount value.
//
// Array: [N]; Units: counts; stroke_type enum used as the index
func (m *Session) SetStrokeCount(v []uint16) *Session {
	m.StrokeCount = v
	return m
}

// SetZoneCount sets ZoneCount value.
//
// Array: [N]; Units: counts; zone number used as the index
func (m *Session) SetZoneCount(v []uint16) *Session {
	m.ZoneCount = v
	return m
}

// SetMaxBallSpeed sets MaxBallSpeed value.
//
// Scale: 100; Units: m/s
func (m *Session) SetMaxBallSpeed(v uint16) *Session {
	m.MaxBallSpeed = v
	return m
}

// SetMaxBallSpeedScaled is similar to SetMaxBallSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m/s
func (m *Session) SetMaxBallSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxBallSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxBallSpeed = uint16(unscaled)
	return m
}

// SetAvgBallSpeed sets AvgBallSpeed value.
//
// Scale: 100; Units: m/s
func (m *Session) SetAvgBallSpeed(v uint16) *Session {
	m.AvgBallSpeed = v
	return m
}

// SetAvgBallSpeedScaled is similar to SetAvgBallSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m/s
func (m *Session) SetAvgBallSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgBallSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgBallSpeed = uint16(unscaled)
	return m
}

// SetAvgVerticalOscillation sets AvgVerticalOscillation value.
//
// Scale: 10; Units: mm
func (m *Session) SetAvgVerticalOscillation(v uint16) *Session {
	m.AvgVerticalOscillation = v
	return m
}

// SetAvgVerticalOscillationScaled is similar to SetAvgVerticalOscillation except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: mm
func (m *Session) SetAvgVerticalOscillationScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgVerticalOscillation = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgVerticalOscillation = uint16(unscaled)
	return m
}

// SetAvgStanceTimePercent sets AvgStanceTimePercent value.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgStanceTimePercent(v uint16) *Session {
	m.AvgStanceTimePercent = v
	return m
}

// SetAvgStanceTimePercentScaled is similar to SetAvgStanceTimePercent except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgStanceTimePercentScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgStanceTimePercent = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgStanceTimePercent = uint16(unscaled)
	return m
}

// SetAvgStanceTime sets AvgStanceTime value.
//
// Scale: 10; Units: ms
func (m *Session) SetAvgStanceTime(v uint16) *Session {
	m.AvgStanceTime = v
	return m
}

// SetAvgStanceTimeScaled is similar to SetAvgStanceTime except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: ms
func (m *Session) SetAvgStanceTimeScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgStanceTime = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgStanceTime = uint16(unscaled)
	return m
}

// SetAvgFractionalCadence sets AvgFractionalCadence value.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *Session) SetAvgFractionalCadence(v uint8) *Session {
	m.AvgFractionalCadence = v
	return m
}

// SetAvgFractionalCadenceScaled is similar to SetAvgFractionalCadence except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *Session) SetAvgFractionalCadenceScaled(v float64) *Session {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgFractionalCadence = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgFractionalCadence = uint8(unscaled)
	return m
}

// SetMaxFractionalCadence sets MaxFractionalCadence value.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *Session) SetMaxFractionalCadence(v uint8) *Session {
	m.MaxFractionalCadence = v
	return m
}

// SetMaxFractionalCadenceScaled is similar to SetMaxFractionalCadence except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *Session) SetMaxFractionalCadenceScaled(v float64) *Session {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.MaxFractionalCadence = uint8(basetype.Uint8Invalid)
		return m
	}
	m.MaxFractionalCadence = uint8(unscaled)
	return m
}

// SetTotalFractionalCycles sets TotalFractionalCycles value.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *Session) SetTotalFractionalCycles(v uint8) *Session {
	m.TotalFractionalCycles = v
	return m
}

// SetTotalFractionalCyclesScaled is similar to SetTotalFractionalCycles except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *Session) SetTotalFractionalCyclesScaled(v float64) *Session {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalCycles = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalCycles = uint8(unscaled)
	return m
}

// SetAvgTotalHemoglobinConc sets AvgTotalHemoglobinConc value.
//
// Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
func (m *Session) SetAvgTotalHemoglobinConc(v []uint16) *Session {
	m.AvgTotalHemoglobinConc = v
	return m
}

// SetAvgTotalHemoglobinConcScaled is similar to SetAvgTotalHemoglobinConc except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
func (m *Session) SetAvgTotalHemoglobinConcScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgTotalHemoglobinConc = nil
		return m
	}
	m.AvgTotalHemoglobinConc = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 100
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.AvgTotalHemoglobinConc[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.AvgTotalHemoglobinConc[i] = uint16(unscaled)
	}
	return m
}

// SetMinTotalHemoglobinConc sets MinTotalHemoglobinConc value.
//
// Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Session) SetMinTotalHemoglobinConc(v []uint16) *Session {
	m.MinTotalHemoglobinConc = v
	return m
}

// SetMinTotalHemoglobinConcScaled is similar to SetMinTotalHemoglobinConc except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Session) SetMinTotalHemoglobinConcScaled(vs []float64) *Session {
	if vs == nil {
		m.MinTotalHemoglobinConc = nil
		return m
	}
	m.MinTotalHemoglobinConc = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 100
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.MinTotalHemoglobinConc[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.MinTotalHemoglobinConc[i] = uint16(unscaled)
	}
	return m
}

// SetMaxTotalHemoglobinConc sets MaxTotalHemoglobinConc value.
//
// Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Session) SetMaxTotalHemoglobinConc(v []uint16) *Session {
	m.MaxTotalHemoglobinConc = v
	return m
}

// SetMaxTotalHemoglobinConcScaled is similar to SetMaxTotalHemoglobinConc except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Session) SetMaxTotalHemoglobinConcScaled(vs []float64) *Session {
	if vs == nil {
		m.MaxTotalHemoglobinConc = nil
		return m
	}
	m.MaxTotalHemoglobinConc = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 100
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.MaxTotalHemoglobinConc[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.MaxTotalHemoglobinConc[i] = uint16(unscaled)
	}
	return m
}

// SetAvgSaturatedHemoglobinPercent sets AvgSaturatedHemoglobinPercent value.
//
// Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
func (m *Session) SetAvgSaturatedHemoglobinPercent(v []uint16) *Session {
	m.AvgSaturatedHemoglobinPercent = v
	return m
}

// SetAvgSaturatedHemoglobinPercentScaled is similar to SetAvgSaturatedHemoglobinPercent except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
func (m *Session) SetAvgSaturatedHemoglobinPercentScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgSaturatedHemoglobinPercent = nil
		return m
	}
	m.AvgSaturatedHemoglobinPercent = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 10
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.AvgSaturatedHemoglobinPercent[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.AvgSaturatedHemoglobinPercent[i] = uint16(unscaled)
	}
	return m
}

// SetMinSaturatedHemoglobinPercent sets MinSaturatedHemoglobinPercent value.
//
// Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Session) SetMinSaturatedHemoglobinPercent(v []uint16) *Session {
	m.MinSaturatedHemoglobinPercent = v
	return m
}

// SetMinSaturatedHemoglobinPercentScaled is similar to SetMinSaturatedHemoglobinPercent except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Session) SetMinSaturatedHemoglobinPercentScaled(vs []float64) *Session {
	if vs == nil {
		m.MinSaturatedHemoglobinPercent = nil
		return m
	}
	m.MinSaturatedHemoglobinPercent = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 10
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.MinSaturatedHemoglobinPercent[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.MinSaturatedHemoglobinPercent[i] = uint16(unscaled)
	}
	return m
}

// SetMaxSaturatedHemoglobinPercent sets MaxSaturatedHemoglobinPercent value.
//
// Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Session) SetMaxSaturatedHemoglobinPercent(v []uint16) *Session {
	m.MaxSaturatedHemoglobinPercent = v
	return m
}

// SetMaxSaturatedHemoglobinPercentScaled is similar to SetMaxSaturatedHemoglobinPercent except it accepts a scaled value.
// This method automatically converts the given value to its []uint16 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Session) SetMaxSaturatedHemoglobinPercentScaled(vs []float64) *Session {
	if vs == nil {
		m.MaxSaturatedHemoglobinPercent = nil
		return m
	}
	m.MaxSaturatedHemoglobinPercent = make([]uint16, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 10
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
			m.MaxSaturatedHemoglobinPercent[i] = uint16(basetype.Uint16Invalid)
			continue
		}
		m.MaxSaturatedHemoglobinPercent[i] = uint16(unscaled)
	}
	return m
}

// SetAvgLeftTorqueEffectiveness sets AvgLeftTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgLeftTorqueEffectiveness(v uint8) *Session {
	m.AvgLeftTorqueEffectiveness = v
	return m
}

// SetAvgLeftTorqueEffectivenessScaled is similar to SetAvgLeftTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgLeftTorqueEffectivenessScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgLeftTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgLeftTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetAvgRightTorqueEffectiveness sets AvgRightTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgRightTorqueEffectiveness(v uint8) *Session {
	m.AvgRightTorqueEffectiveness = v
	return m
}

// SetAvgRightTorqueEffectivenessScaled is similar to SetAvgRightTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgRightTorqueEffectivenessScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgRightTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgRightTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetAvgLeftPedalSmoothness sets AvgLeftPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgLeftPedalSmoothness(v uint8) *Session {
	m.AvgLeftPedalSmoothness = v
	return m
}

// SetAvgLeftPedalSmoothnessScaled is similar to SetAvgLeftPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgLeftPedalSmoothnessScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgLeftPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgLeftPedalSmoothness = uint8(unscaled)
	return m
}

// SetAvgRightPedalSmoothness sets AvgRightPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgRightPedalSmoothness(v uint8) *Session {
	m.AvgRightPedalSmoothness = v
	return m
}

// SetAvgRightPedalSmoothnessScaled is similar to SetAvgRightPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgRightPedalSmoothnessScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgRightPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgRightPedalSmoothness = uint8(unscaled)
	return m
}

// SetAvgCombinedPedalSmoothness sets AvgCombinedPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgCombinedPedalSmoothness(v uint8) *Session {
	m.AvgCombinedPedalSmoothness = v
	return m
}

// SetAvgCombinedPedalSmoothnessScaled is similar to SetAvgCombinedPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Session) SetAvgCombinedPedalSmoothnessScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgCombinedPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgCombinedPedalSmoothness = uint8(unscaled)
	return m
}

// SetSportProfileName sets SportProfileName value.
//
// Sport name from associated sport mesg
func (m *Session) SetSportProfileName(v string) *Session {
	m.SportProfileName = v
	return m
}

// SetSportIndex sets SportIndex value.
func (m *Session) SetSportIndex(v uint8) *Session {
	m.SportIndex = v
	return m
}

// SetTimeStanding sets TimeStanding value.
//
// Scale: 1000; Units: s; Total time spend in the standing position
func (m *Session) SetTimeStanding(v uint32) *Session {
	m.TimeStanding = v
	return m
}

// SetTimeStandingScaled is similar to SetTimeStanding except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Total time spend in the standing position
func (m *Session) SetTimeStandingScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TimeStanding = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TimeStanding = uint32(unscaled)
	return m
}

// SetStandCount sets StandCount value.
//
// Number of transitions to the standing state
func (m *Session) SetStandCount(v uint16) *Session {
	m.StandCount = v
	return m
}

// SetAvgLeftPco sets AvgLeftPco value.
//
// Units: mm; Average platform center offset Left
func (m *Session) SetAvgLeftPco(v int8) *Session {
	m.AvgLeftPco = v
	return m
}

// SetAvgRightPco sets AvgRightPco value.
//
// Units: mm; Average platform center offset Right
func (m *Session) SetAvgRightPco(v int8) *Session {
	m.AvgRightPco = v
	return m
}

// SetAvgLeftPowerPhase sets AvgLeftPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhase(v []uint8) *Session {
	m.AvgLeftPowerPhase = v
	return m
}

// SetAvgLeftPowerPhaseScaled is similar to SetAvgLeftPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhaseScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgLeftPowerPhase = nil
		return m
	}
	m.AvgLeftPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgLeftPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgLeftPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetAvgLeftPowerPhasePeak sets AvgLeftPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhasePeak(v []uint8) *Session {
	m.AvgLeftPowerPhasePeak = v
	return m
}

// SetAvgLeftPowerPhasePeakScaled is similar to SetAvgLeftPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhasePeakScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgLeftPowerPhasePeak = nil
		return m
	}
	m.AvgLeftPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgLeftPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgLeftPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetAvgRightPowerPhase sets AvgRightPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhase(v []uint8) *Session {
	m.AvgRightPowerPhase = v
	return m
}

// SetAvgRightPowerPhaseScaled is similar to SetAvgRightPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhaseScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgRightPowerPhase = nil
		return m
	}
	m.AvgRightPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgRightPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgRightPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetAvgRightPowerPhasePeak sets AvgRightPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhasePeak(v []uint8) *Session {
	m.AvgRightPowerPhasePeak = v
	return m
}

// SetAvgRightPowerPhasePeakScaled is similar to SetAvgRightPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhasePeakScaled(vs []float64) *Session {
	if vs == nil {
		m.AvgRightPowerPhasePeak = nil
		return m
	}
	m.AvgRightPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgRightPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgRightPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetAvgPowerPosition sets AvgPowerPosition value.
//
// Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
func (m *Session) SetAvgPowerPosition(v []uint16) *Session {
	m.AvgPowerPosition = v
	return m
}

// SetMaxPowerPosition sets MaxPowerPosition value.
//
// Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
func (m *Session) SetMaxPowerPosition(v []uint16) *Session {
	m.MaxPowerPosition = v
	return m
}

// SetAvgCadencePosition sets AvgCadencePosition value.
//
// Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
func (m *Session) SetAvgCadencePosition(v []uint8) *Session {
	m.AvgCadencePosition = v
	return m
}

// SetMaxCadencePosition sets MaxCadencePosition value.
//
// Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
func (m *Session) SetMaxCadencePosition(v []uint8) *Session {
	m.MaxCadencePosition = v
	return m
}

// SetEnhancedAvgSpeed sets EnhancedAvgSpeed value.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetEnhancedAvgSpeed(v uint32) *Session {
	m.EnhancedAvgSpeed = v
	return m
}

// SetEnhancedAvgSpeedScaled is similar to SetEnhancedAvgSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetEnhancedAvgSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedAvgSpeed = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedAvgSpeed = uint32(unscaled)
	return m
}

// SetEnhancedMaxSpeed sets EnhancedMaxSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetEnhancedMaxSpeed(v uint32) *Session {
	m.EnhancedMaxSpeed = v
	return m
}

// SetEnhancedMaxSpeedScaled is similar to SetEnhancedMaxSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetEnhancedMaxSpeedScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedMaxSpeed = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedMaxSpeed = uint32(unscaled)
	return m
}

// SetEnhancedAvgAltitude sets EnhancedAvgAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedAvgAltitude(v uint32) *Session {
	m.EnhancedAvgAltitude = v
	return m
}

// SetEnhancedAvgAltitudeScaled is similar to SetEnhancedAvgAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedAvgAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedAvgAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedAvgAltitude = uint32(unscaled)
	return m
}

// SetEnhancedMinAltitude sets EnhancedMinAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedMinAltitude(v uint32) *Session {
	m.EnhancedMinAltitude = v
	return m
}

// SetEnhancedMinAltitudeScaled is similar to SetEnhancedMinAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedMinAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedMinAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedMinAltitude = uint32(unscaled)
	return m
}

// SetEnhancedMaxAltitude sets EnhancedMaxAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedMaxAltitude(v uint32) *Session {
	m.EnhancedMaxAltitude = v
	return m
}

// SetEnhancedMaxAltitudeScaled is similar to SetEnhancedMaxAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Session) SetEnhancedMaxAltitudeScaled(v float64) *Session {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedMaxAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedMaxAltitude = uint32(unscaled)
	return m
}

// SetAvgLevMotorPower sets AvgLevMotorPower value.
//
// Units: watts; lev average motor power during session
func (m *Session) SetAvgLevMotorPower(v uint16) *Session {
	m.AvgLevMotorPower = v
	return m
}

// SetMaxLevMotorPower sets MaxLevMotorPower value.
//
// Units: watts; lev maximum motor power during session
func (m *Session) SetMaxLevMotorPower(v uint16) *Session {
	m.MaxLevMotorPower = v
	return m
}

// SetLevBatteryConsumption sets LevBatteryConsumption value.
//
// Scale: 2; Units: percent; lev battery consumption during session
func (m *Session) SetLevBatteryConsumption(v uint8) *Session {
	m.LevBatteryConsumption = v
	return m
}

// SetLevBatteryConsumptionScaled is similar to SetLevBatteryConsumption except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent; lev battery consumption during session
func (m *Session) SetLevBatteryConsumptionScaled(v float64) *Session {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.LevBatteryConsumption = uint8(basetype.Uint8Invalid)
		return m
	}
	m.LevBatteryConsumption = uint8(unscaled)
	return m
}

// SetAvgVerticalRatio sets AvgVerticalRatio value.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgVerticalRatio(v uint16) *Session {
	m.AvgVerticalRatio = v
	return m
}

// SetAvgVerticalRatioScaled is similar to SetAvgVerticalRatio except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgVerticalRatioScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgVerticalRatio = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgVerticalRatio = uint16(unscaled)
	return m
}

// SetAvgStanceTimeBalance sets AvgStanceTimeBalance value.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgStanceTimeBalance(v uint16) *Session {
	m.AvgStanceTimeBalance = v
	return m
}

// SetAvgStanceTimeBalanceScaled is similar to SetAvgStanceTimeBalance except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Session) SetAvgStanceTimeBalanceScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgStanceTimeBalance = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgStanceTimeBalance = uint16(unscaled)
	return m
}

// SetAvgStepLength sets AvgStepLength value.
//
// Scale: 10; Units: mm
func (m *Session) SetAvgStepLength(v uint16) *Session {
	m.AvgStepLength = v
	return m
}

// SetAvgStepLengthScaled is similar to SetAvgStepLength except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: mm
func (m *Session) SetAvgStepLengthScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgStepLength = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgStepLength = uint16(unscaled)
	return m
}

// SetTotalAnaerobicTrainingEffect sets TotalAnaerobicTrainingEffect value.
//
// Scale: 10
func (m *Session) SetTotalAnaerobicTrainingEffect(v uint8) *Session {
	m.TotalAnaerobicTrainingEffect = v
	return m
}

// SetTotalAnaerobicTrainingEffectScaled is similar to SetTotalAnaerobicTrainingEffect except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 10
func (m *Session) SetTotalAnaerobicTrainingEffectScaled(v float64) *Session {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalAnaerobicTrainingEffect = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalAnaerobicTrainingEffect = uint8(unscaled)
	return m
}

// SetAvgVam sets AvgVam value.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgVam(v uint16) *Session {
	m.AvgVam = v
	return m
}

// SetAvgVamScaled is similar to SetAvgVam except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Session) SetAvgVamScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgVam = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgVam = uint16(unscaled)
	return m
}

// SetAvgDepth sets AvgDepth value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetAvgDepth(v uint32) *Session {
	m.AvgDepth = v
	return m
}

// SetAvgDepthScaled is similar to SetAvgDepth except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetAvgDepthScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.AvgDepth = uint32(basetype.Uint32Invalid)
		return m
	}
	m.AvgDepth = uint32(unscaled)
	return m
}

// SetMaxDepth sets MaxDepth value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetMaxDepth(v uint32) *Session {
	m.MaxDepth = v
	return m
}

// SetMaxDepthScaled is similar to SetMaxDepth except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetMaxDepthScaled(v float64) *Session {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.MaxDepth = uint32(basetype.Uint32Invalid)
		return m
	}
	m.MaxDepth = uint32(unscaled)
	return m
}

// SetSurfaceInterval sets SurfaceInterval value.
//
// Units: s; Time since end of last dive
func (m *Session) SetSurfaceInterval(v uint32) *Session {
	m.SurfaceInterval = v
	return m
}

// SetStartCns sets StartCns value.
//
// Units: percent
func (m *Session) SetStartCns(v uint8) *Session {
	m.StartCns = v
	return m
}

// SetEndCns sets EndCns value.
//
// Units: percent
func (m *Session) SetEndCns(v uint8) *Session {
	m.EndCns = v
	return m
}

// SetStartN2 sets StartN2 value.
//
// Units: percent
func (m *Session) SetStartN2(v uint16) *Session {
	m.StartN2 = v
	return m
}

// SetEndN2 sets EndN2 value.
//
// Units: percent
func (m *Session) SetEndN2(v uint16) *Session {
	m.EndN2 = v
	return m
}

// SetAvgRespirationRate sets AvgRespirationRate value.
func (m *Session) SetAvgRespirationRate(v uint8) *Session {
	m.AvgRespirationRate = v
	return m
}

// SetMaxRespirationRate sets MaxRespirationRate value.
func (m *Session) SetMaxRespirationRate(v uint8) *Session {
	m.MaxRespirationRate = v
	return m
}

// SetMinRespirationRate sets MinRespirationRate value.
func (m *Session) SetMinRespirationRate(v uint8) *Session {
	m.MinRespirationRate = v
	return m
}

// SetMinTemperature sets MinTemperature value.
//
// Units: C
func (m *Session) SetMinTemperature(v int8) *Session {
	m.MinTemperature = v
	return m
}

// SetO2Toxicity sets O2Toxicity value.
//
// Units: OTUs
func (m *Session) SetO2Toxicity(v uint16) *Session {
	m.O2Toxicity = v
	return m
}

// SetDiveNumber sets DiveNumber value.
func (m *Session) SetDiveNumber(v uint32) *Session {
	m.DiveNumber = v
	return m
}

// SetTrainingLoadPeak sets TrainingLoadPeak value.
//
// Scale: 65536
func (m *Session) SetTrainingLoadPeak(v int32) *Session {
	m.TrainingLoadPeak = v
	return m
}

// SetTrainingLoadPeakScaled is similar to SetTrainingLoadPeak except it accepts a scaled value.
// This method automatically converts the given value to its int32 form, discarding any applied scale and offset.
//
// Scale: 65536
func (m *Session) SetTrainingLoadPeakScaled(v float64) *Session {
	unscaled := (v + 0) * 65536
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint32Invalid) {
		m.TrainingLoadPeak = int32(basetype.Sint32Invalid)
		return m
	}
	m.TrainingLoadPeak = int32(unscaled)
	return m
}

// SetEnhancedAvgRespirationRate sets EnhancedAvgRespirationRate value.
//
// Scale: 100; Units: Breaths/min
func (m *Session) SetEnhancedAvgRespirationRate(v uint16) *Session {
	m.EnhancedAvgRespirationRate = v
	return m
}

// SetEnhancedAvgRespirationRateScaled is similar to SetEnhancedAvgRespirationRate except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: Breaths/min
func (m *Session) SetEnhancedAvgRespirationRateScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.EnhancedAvgRespirationRate = uint16(basetype.Uint16Invalid)
		return m
	}
	m.EnhancedAvgRespirationRate = uint16(unscaled)
	return m
}

// SetEnhancedMaxRespirationRate sets EnhancedMaxRespirationRate value.
//
// Scale: 100; Units: Breaths/min
func (m *Session) SetEnhancedMaxRespirationRate(v uint16) *Session {
	m.EnhancedMaxRespirationRate = v
	return m
}

// SetEnhancedMaxRespirationRateScaled is similar to SetEnhancedMaxRespirationRate except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: Breaths/min
func (m *Session) SetEnhancedMaxRespirationRateScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.EnhancedMaxRespirationRate = uint16(basetype.Uint16Invalid)
		return m
	}
	m.EnhancedMaxRespirationRate = uint16(unscaled)
	return m
}

// SetEnhancedMinRespirationRate sets EnhancedMinRespirationRate value.
//
// Scale: 100
func (m *Session) SetEnhancedMinRespirationRate(v uint16) *Session {
	m.EnhancedMinRespirationRate = v
	return m
}

// SetEnhancedMinRespirationRateScaled is similar to SetEnhancedMinRespirationRate except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100
func (m *Session) SetEnhancedMinRespirationRateScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.EnhancedMinRespirationRate = uint16(basetype.Uint16Invalid)
		return m
	}
	m.EnhancedMinRespirationRate = uint16(unscaled)
	return m
}

// SetTotalGrit sets TotalGrit value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *Session) SetTotalGrit(v float32) *Session {
	m.TotalGrit = v
	return m
}

// SetTotalFlow sets TotalFlow value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *Session) SetTotalFlow(v float32) *Session {
	m.TotalFlow = v
	return m
}

// SetJumpCount sets JumpCount value.
func (m *Session) SetJumpCount(v uint16) *Session {
	m.JumpCount = v
	return m
}

// SetAvgGrit sets AvgGrit value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *Session) SetAvgGrit(v float32) *Session {
	m.AvgGrit = v
	return m
}

// SetAvgFlow sets AvgFlow value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *Session) SetAvgFlow(v float32) *Session {
	m.AvgFlow = v
	return m
}

// SetWorkoutFeel sets WorkoutFeel value.
//
// A 0-100 scale representing how a user felt while performing a workout. Low values are considered feeling bad, while high values are good.
func (m *Session) SetWorkoutFeel(v uint8) *Session {
	m.WorkoutFeel = v
	return m
}

// SetWorkoutRpe sets WorkoutRpe value.
//
// Common Borg CR10 / 0-10 RPE scale, multiplied 10x.. Aggregate score for all workouts in a single session.
func (m *Session) SetWorkoutRpe(v uint8) *Session {
	m.WorkoutRpe = v
	return m
}

// SetAvgSpo2 sets AvgSpo2 value.
//
// Units: percent; Average SPO2 for the monitoring session
func (m *Session) SetAvgSpo2(v uint8) *Session {
	m.AvgSpo2 = v
	return m
}

// SetAvgStress sets AvgStress value.
//
// Units: percent; Average stress for the monitoring session
func (m *Session) SetAvgStress(v uint8) *Session {
	m.AvgStress = v
	return m
}

// SetSdrrHrv sets SdrrHrv value.
//
// Units: mS; Standard deviation of R-R interval (SDRR) - Heart rate variability measure most useful for wellness users.
func (m *Session) SetSdrrHrv(v uint8) *Session {
	m.SdrrHrv = v
	return m
}

// SetRmssdHrv sets RmssdHrv value.
//
// Units: mS; Root mean square successive difference (RMSSD) - Heart rate variability measure most useful for athletes
func (m *Session) SetRmssdHrv(v uint8) *Session {
	m.RmssdHrv = v
	return m
}

// SetTotalFractionalAscent sets TotalFractionalAscent value.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *Session) SetTotalFractionalAscent(v uint8) *Session {
	m.TotalFractionalAscent = v
	return m
}

// SetTotalFractionalAscentScaled is similar to SetTotalFractionalAscent except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *Session) SetTotalFractionalAscentScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalAscent = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalAscent = uint8(unscaled)
	return m
}

// SetTotalFractionalDescent sets TotalFractionalDescent value.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *Session) SetTotalFractionalDescent(v uint8) *Session {
	m.TotalFractionalDescent = v
	return m
}

// SetTotalFractionalDescentScaled is similar to SetTotalFractionalDescent except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *Session) SetTotalFractionalDescentScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalDescent = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalDescent = uint8(unscaled)
	return m
}

// SetAvgCoreTemperature sets AvgCoreTemperature value.
//
// Scale: 100; Units: C
func (m *Session) SetAvgCoreTemperature(v uint16) *Session {
	m.AvgCoreTemperature = v
	return m
}

// SetAvgCoreTemperatureScaled is similar to SetAvgCoreTemperature except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: C
func (m *Session) SetAvgCoreTemperatureScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgCoreTemperature = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgCoreTemperature = uint16(unscaled)
	return m
}

// SetMinCoreTemperature sets MinCoreTemperature value.
//
// Scale: 100; Units: C
func (m *Session) SetMinCoreTemperature(v uint16) *Session {
	m.MinCoreTemperature = v
	return m
}

// SetMinCoreTemperatureScaled is similar to SetMinCoreTemperature except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: C
func (m *Session) SetMinCoreTemperatureScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MinCoreTemperature = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MinCoreTemperature = uint16(unscaled)
	return m
}

// SetMaxCoreTemperature sets MaxCoreTemperature value.
//
// Scale: 100; Units: C
func (m *Session) SetMaxCoreTemperature(v uint16) *Session {
	m.MaxCoreTemperature = v
	return m
}

// SetMaxCoreTemperatureScaled is similar to SetMaxCoreTemperature except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: C
func (m *Session) SetMaxCoreTemperatureScaled(v float64) *Session {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxCoreTemperature = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxCoreTemperature = uint16(unscaled)
	return m
}

// SetUnknownFields sets UnknownFields (fields that are exist but they are not defined in Profile.xlsx)
func (m *Session) SetUnknownFields(unknownFields ...proto.Field) *Session {
	m.UnknownFields = unknownFields
	return m
}

// SetDeveloperFields sets DeveloperFields.
func (m *Session) SetDeveloperFields(developerFields ...proto.DeveloperField) *Session {
	m.DeveloperFields = developerFields
	return m
}

// MarkAsExpandedField marks whether given fieldNum is an expanded field (field that being
// generated through a component expansion). Eligible for field number: 124, 125, 126, 127, 128, 169, 170, 180.
func (m *Session) MarkAsExpandedField(fieldNum byte, flag bool) (ok bool) {
	switch fieldNum {
	case 124, 125, 126, 127, 128, 169, 170, 180:
	default:
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	m.state[pos] &^= bit
	if flag {
		m.state[pos] |= bit
	}
	return true
}

// IsExpandedField checks whether given fieldNum is a field generated through
// a component expansion. Eligible for field number: 124, 125, 126, 127, 128, 169, 170, 180.
func (m *Session) IsExpandedField(fieldNum byte) bool {
	if fieldNum >= 181 {
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	return m.state[pos]&bit == bit
}
